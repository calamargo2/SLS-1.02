Info file make.info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

   This file documents the GNU Make utility.

   Copyright (C) 1988-1991 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: make.info,  Node: Foreach Function,  Next: Origin Function,  Prev: Filename Functions,  Up: Functions

The `foreach' Function
======================

   The `foreach' function is very different from other functions.  It
causes one piece of text to be used repeatedly, each time with a
different substitution performed on it.  It resembles the `for'
command in the shell `sh' and the `foreach' command in the C-shell
`csh'.

   The syntax of the `foreach' function is:

     $(foreach VAR,LIST,TEXT)

The first two arguments, VAR and LIST, are expanded before anything
else is done; note that the last argument, TEXT, is *not* expanded at
the same time.  Then for each word of the expanded value of LIST, the
variable named by the expanded value of VAR is set to that word, and
TEXT is expanded.  Presumably TEXT contains references to that
variable, so its expansion will be different each time.

   The result is that TEXT is expanded as many times as there are
whitespace-separated words in LIST.  The multiple expansions of TEXT
are concatenated, with spaces between them, to make the result of
`foreach'.

   This simple example sets the variable `files' to the list of all
files in the directories in the list `dirs':

     dirs := a b c d
     files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))

   Here TEXT is `$(wildcard $(dir)/*)'.  The first repetition finds
the value `a' for `dir', so it produces the same result as `$(wildcard
a/*)'; the second repetition produces the result of `$(wildcard b/*)';
and the third, that of `$(wildcard c/*)'.

   This example has the same result (except for setting `find_files',
`dirs' and `dir') as the following example:

     files := $(wildcard a/* b/* c/* d/*)

   When TEXT is complicated, you can improve readability by giving it
a name, with an additional variable:

     find_files = $(wildcard $(dir)/*)
     dirs := a b c d
     files := $(foreach dir,$(dirs),$(find_files))

Here we use the variable `find_files' this way.  We use plain `=' to
define a recursively-expanding variable, so that its value contains an
actual function call to be reexpanded under the control of `foreach';
a simply-expanded variable would not do, since `wildcard' would be
called only once at the time of defining `find_files'.

   The `foreach' function has no permanent effect on the variable VAR;
its value and flavor after the `foreach' function call are the same as
they were beforehand.  The other values which are taken from LIST are
in effect only temporarily, during the execution of `foreach'.  The
variable VAR is a simply-expanded variable during the execution of
`foreach'.  If VAR was undefined before the `foreach' function call,
it is undefined after the call.  *Note Flavors::.

   You must take care when using complex variable expressions that
result in variable names because many strange things are valid
variable names, but are probably not what you intended.  For example,

     files := $(foreach Es escrito en espanol!,b c ch,$(find_files))

might be useful if the value of `find_files' references the variable
whose name is `Es escrito en espanol!' (es un nombre bastante largo,
que no?), but it is more likely to be a mistake.


File: make.info,  Node: Origin Function,  Next: Shell Function,  Prev: Foreach Function,  Up: Functions

The `origin' Function
=====================

   The `origin' function is unlike most other functions in that it does
not operate on the values of variables; it tells you something *about*
a variable.  Specifically, it tells you where it came from.

   The syntax of the `origin' function is:

     $(origin VARIABLE)

   Note that VARIABLE is the *name* of a variable to inquire about;
not a *reference* to that variable.  Therefore you would not normally
use a `$' or parentheses when writing it.  (You can, however, use a
variable reference in the name if you want the name not to be a
constant.)

   The result of this function is a string telling you how the variable
VARIABLE was defined:

`undefined'
     if VARIABLE was never defined.

`default'
     if VARIABLE has a default definition, as is usual with `CC' and
     so on.  *Note Implicit Variables::.  Note that if you have
     redefined a default variable, the `origin' function will return
     the origin of the later definition.

`environment'
     if VARIABLE was defined as an environment variable and the `-e'
     option is *not* turned on (*note Options::.).

`environment override'
     if VARIABLE was defined as an environment variable and the `-e'
     option *is* turned on (*note Options::.).

`file'
     if VARIABLE was defined in a makefile.

`command line'
     if VARIABLE was defined on the command line.

`override'
     if VARIABLE was defined with an `override' directive in a
     makefile (*note Override Directive::.).

`automatic'
     if VARIABLE is an automatic variable defined for the execution of
     the commands for each rule.

   This information is primarily useful (other than for your
curiosity) to determine if you want to believe the value of a
variable.  For example, suppose you have a makefile `foo' that
includes another makefile `bar'.  You want a variable `bletch' to be
defined in `bar' if you run the command `make -f bar', even if the
environment contains a definition of `bletch'.  However, if `foo'
defined `bletch' before including `bar', you don't want to override
that definition.  This could be done by using an `override' directive
in `foo', giving that definition precedence over the later definition
in `bar'; unfortunately, the `override' directive would also override
any command line definitions.  So, `bar' could include:

     ifdef bletch
     ifeq "$(origin bletch)" "environment"
     bletch = barf, gag, etc.
     endif
     endif

If `bletch' has been defined from the environment, this will redefine
it.

   If you want to override a previous definition of `bletch' if it came
from the environment, even under `-e', you could instead write:

     ifneq "$(findstring environment,$(origin bletch))" ""
     bletch = barf, gag, etc.
     endif

   Here the redefinition takes place if `$(origin bletch)' returns
either `environment' or `environment override'.


File: make.info,  Node: Shell Function,  Prev: Origin Function,  Up: Functions

The `shell' Function
====================

   The `shell' function is unlike any other function except the
`wildcard' function (*note Wildcard Function::.) in that it
communicates with the world outside of `make'.

   The `shell' function performs the same function that backquotes
(``') perform in most shells: it does "command expansion".  This means
that it takes an argument that is a shell command and returns the
output of the command.  The only processing `make' does on the result,
before substituting it into the surrounding text, is to convert
newlines to spaces.

   The commands run by calls to the `shell' function are run when the
function calls are expanded.  In most cases, this is when the makefile
is read in.  The exception is that function calls in the commands of
the rules are expanded when the commands are run, and this applies to
`shell' function calls like all others.

   Here are some examples of the use of the `shell' function:

     contents := $(shell cat foo)

sets `contents' to the contents of the file `foo', with a space
(rather than a newline) separating each line.

     files := $(shell echo *.c)

sets `files' to the expansion of `*.c'.  Unless `make' is using a very
strange shell, this has the same result as `$(wildcard *.c)'.


File: make.info,  Node: Running,  Next: Implicit,  Prev: Functions,  Up: Top

How to Run `make'
*****************

   A makefile that says how to recompile a program can be used in more
than one way.  The simplest use is to recompile every file that is out
of date.  This is what `make' will do if run with no arguments.

   But you might want to update only some of the files; you might want
to use a different compiler or different compiler options; you might
want just to find out which files are out of date without changing
them.

   By specifying arguments when you run `make', you can do any of these
things or many others.

* Menu:

* Makefile Arguments::    Arguments to specify which makefile to use.

* Goals::                 Goal arguments specify which parts of the makefile
                           should be used.

* Instead of Execution::  Mode flags specify what kind of thing to do
                           with the commands in the makefile
                           other than simply execute them.

* Avoiding Compilation::  How to avoid recompiling certain files.

* Overriding::            Overriding a variable can specify an alternate
                           compiler, or alternate flags for the compiler,
                           or whatever else you program into the makefile.

* Testing::               How to proceed past some errors, to test compilation.

* Options::               Summary of all options `make' accepts.


File: make.info,  Node: Makefile Arguments,  Next: Goals,  Prev: Running,  Up: Running

Arguments to Specify the Makefile
=================================

   The way to specify the name of the makefile is with the `-f' option. 
For example, `-f altmake' says to use the file `altmake' as the
makefile.

   If you use the `-f' flag several times (each time with a following
argument), all the specified files are used jointly as makefiles.

   If you do not use the `-f' flag, the default is to try
`GNUmakefile', `makefile', or `Makefile', in that order, and use the
first of these three which exists.  *Note Makefiles::.


File: make.info,  Node: Goals,  Next: Instead of Execution,  Prev: Makefile Arguments,  Up: Running

Arguments to Specify the Goals
==============================

   The "goals" are the targets that `make' should strive ultimately to
update.  Other targets are updated as well if they appear as
dependencies of goals, or dependencies of dependencies of goals, etc.

   By default, the goal is the first target in the makefile (not
counting targets that start with a period).  Therefore, makefiles are
usually written so that the first target is for compiling the entire
program or programs they describe.

   You can specify a different goal or goals with arguments to `make'. 
Use the name of the goal as an argument.  If you specify several goals,
`make' processes each of them in turn, in the order you name them.

   Any target in the makefile may be specified as a goal (unless it
starts with `-' or contains an `=').  Even targets not in the makefile
may be specified, if `make' can find implicit rules that say how to
make them.

   One use of specifying a goal is if you want to compile only a part
of the program, or only one of several programs.  Specify as a goal
each file that you wish to remake.  For example, consider a directory
containing several programs, with a makefile that starts like this:

     .PHONY: all
     all: size nm ld ar as

   If you are working on the program `size', you might want to say
`make size' so that only the files of that program are recompiled.

   Another use of specifying a goal is to make files that aren't
normally made.  For example, there may be a file of debugging output,
or a version of the program that is compiled specially for testing,
which has a rule in the makefile but isn't a dependency of the default
goal.

   Another use of specifying a goal is to run the commands associated
with a phony target (*note Phony Targets::.) or empty target (*note
Empty Targets::.).  Many makefiles contain a phony target named
`clean' which deletes everything except source files.  Naturally, this
is done only if you request it explicitly with `make clean'.  Here is
a list of typical phony and empty target names:

`all'
     Make all the top-level targets the makefile knows about.

`clean'
     Delete all files that are normally created by running `make'.

`distclean'
`realclean'
`clobber'
     Any of these three might be defined to delete everything that
     would not be part of a standard distribution.  For example, this
     would delete configuration files or links that you would normally
     create as preparation for compilation, even if the makefile
     itself cannot create these files.

`install'
     Copy the executable file into a directory that users typically
     search for commands; copy any auxiliary files that the executable
     uses into the directories where it will look for them.

`print'
     Print listings of the source files that have changed.

`tar'
     Create a tar file of the source files.

`shar'
     Create a shell archive (shar file) of the source files.

`dist'
     Create a distribution file of the source files.  This might be a
     tar file, or a shar file, or a compressed version of one of the
     above, or even more than one of the above.


File: make.info,  Node: Instead of Execution,  Next: Avoiding Compilation,  Prev: Goals,  Up: Running

Instead of Executing the Commands
=================================

   The makefile tells `make' how to tell whether a target is up to
date, and how to update each target.  But updating the targets is not
always what you want.  Certain options specify other activities for
`make'.

`-t'
     "Touch".  The activity is to mark the targets as up to date
     without actually changing them.  In other words, `make' pretends
     to compile the targets but does not really change their contents.

`-n'
     "No-op".  The activity is to print what commands would be used to
     make the targets up to date, but not actually execute them.

`-q'
     "Question".  The activity is to find out silently whether the
     targets are up to date already; but execute no commands in either
     case.  In other words, neither compilation nor output will occur.

`-W'
     "What if".  Each `-W' flag is followed by a file name.  The given
     files' modification times are recorded by `make' as being the
     present time, although the actual modification times remain the
     same.  When used in conjunction with the `-n' flag, the `-W' flag
     provides a way to see what would happen if you were to modify
     specific files.

   With the `-n' flag, `make' prints without execution the commands
that it would normally execute.

   With the `-t' flag, `make' ignores the commands in the rules and
uses (in effect) the command `touch' for each target that needs to be
remade.  The `touch' command is also printed, unless `-s' or `.SILENT'
is used.  For speed, `make' does not actually invoke the program
`touch'.  It does the work directly.

   With the `-q' flag, `make' prints nothing and executes no commands,
but the exit status code it returns is zero if and only if the targets
to be considered are already up to date.

   It is an error to use more than one of these three flags in the same
invocation of `make'.

   The `-n', `-t', and `-q' options do not affect command lines that
begin with `+' characters or contain the strings `$(MAKE)' or
`${MAKE}'.  Note that only the line containing the `+' character or
the strings `$(MAKE)' or `${MAKE}' is run regardless of these options.
 Other lines in the same rule are not run unless they too begin with
`+' or contain `$(MAKE)' or `${MAKE}'.

   The `-W' flag provides two features:

   * If you also use the `-n' or `-q' flag, you can see what `make'
     would do if you were to modify some files.

   * Without the `-n' or `-q' flag, when `make' is actually executing
     commands, the `-W' flag can direct `make' to act as if some files
     had been modified, without actually modifying the files.

   Note that the options `-p' and `-v' allow you to obtain other
information about `make' or about the makefiles in use.  *Note
Options::.


File: make.info,  Node: Avoiding Compilation,  Next: Overriding,  Prev: Instead of Execution,  Up: Running

Avoiding Recompilation of Some Files
====================================

   Sometimes you may have changed a source file but you don't want to
recompile all the files that depend on it.  For example, suppose you
add a macro or a declaration to a header file that many other files
depend on.  Being conservative, `make' assumes that any change in the
header file requires recompilation of all dependent files, but you
know that they don't need to be recompiled and you would rather not
waste the time waiting for them to compile.

   If you anticipate the problem before changing the header file, you
can use the `-t' flag.  This flag tells `make' not to run the commands
in the rules, but rather to mark the target up to date by changing its
last-modification date.  You would follow this procedure:

  1. Use the command `make' to recompile the source files that really
     need recompilation.

  2. Make the changes in the header files.

  3. Use the command `make -t' to mark all the object files as up to
     date.  The next time you run `make', the changes in the header
     files will not cause any recompilation.

   If you have already changed the header file at a time when some
files do need recompilation, it is too late to do this.  Instead, you
can use the `-o FILE' flag, which marks a specified file as "old"
(*note Options::.).  This means that the file itself won't be remade,
and nothing else will be remade on its account.  Follow this procedure:

  1. Recompile the source files that need compilation for reasons
     independent of the particular header file, with `make -o
     HEADERFILE'.  If several header files are involved, use a
     separate `-o' option for each header file.

  2. Touch all the object files with `make -t'.


File: make.info,  Node: Overriding,  Next: Testing,  Prev: Avoiding Compilation,  Up: Running

Overriding Variables
====================

   An argument that contains `=' specifies the value of a variable:
`V=X' sets the value of the variable V to X.  If you specify a value
in this way, all ordinary assignments of the same variable in the
makefile are ignored; we say they have been "overridden" by the
command line argument.

   The most common way to use this facility is to pass extra flags to
compilers.  For example, in a properly written makefile, the variable
`CFLAGS' is included in each command that runs the C compiler, so a
file `foo.c' would be compiled something like this:

     cc -c $(CFLAGS) foo.c

   Thus, whatever value you set for `CFLAGS' affects each compilation
that occurs.  The makefile probably specifies the usual value for
`CFLAGS', like this:

     CFLAGS=-g

   Each time you run `make', you can override this value if you wish. 
For example, if you say `make CFLAGS='-g -O'', each C compilation will
be done with `cc -c -g -O'.  (This illustrates how you can enclose
spaces and other special characters in the value of a variable when you
override it.)

   The variable `CFLAGS' is only one of many standard variables that
exist just so that you can change them this way.  *Note Implicit
Variables::, for a complete list.

   You can also program the makefile to look at additional variables
of your own, giving the user the ability to control other aspects of
how the makefile works by changing the variables.

   When you override a variable with a command argument, you can
define either a recursively-expanded variable or a simply-expanded
variable.  The examples shown above make a recursively-expanded
variable; to make a simply-expanded variable, write `:=' instead of
`='.  But, unless you want to include a variable reference or function
call in the *value* that you specify, it makes no difference which
kind of variable you create.

   There is one way that the makefile can change a variable that you
have overridden.  This is to use the `override' directive, which is a
line that looks like this: `override VARIABLE = VALUE'.  *Note
Override Directive::.


File: make.info,  Node: Testing,  Next: Options,  Prev: Overriding,  Up: Running

Testing the Compilation of a Program
====================================

   Normally, when an error happens in executing a shell command, `make'
gives up immediately, returning a nonzero status.  No further commands
are executed for any target.  The error implies that the goal cannot be
correctly remade, and `make' reports this as soon as it knows.

   When you are compiling a program that you have just changed, this
is not what you want.  Instead, you would rather that `make' try
compiling every file that can be tried, to show you as many
compilation errors as possible.

   On these occasions, you should use the `-k' flag.  This tells
`make' to continue to consider the other dependencies of the pending
targets, remaking them if necessary, before it gives up and returns
nonzero status.  For example, after an error in compiling one object
file, `make -k' will continue compiling other object files even though
it already knows that linking them will be impossible.  In addition to
continuing after failed shell commands, `make -k' will continue as much
as possible after discovering that it doesn't know how to make a
target or dependency file.  This will always cause an error message,
but without `-k', it is a fatal error.  *Note Options::.

   The usual behavior of `make' assumes that your purpose is to get the
goals up to date; once `make' learns that this is impossible, it might
as well report the failure immediately.  The `-k' flag says that the
real purpose is to test as much as possible of the changes made in the
program, perhaps to find several independent problems so that you can
correct them all before the next attempt to compile.  This is why
Emacs's `M-x compile' command passes the `-k' flag by default.


File: make.info,  Node: Options,  Prev: Testing,  Up: Running

Summary of Options
==================

   Here is a table of all the options `make' understands:

`-b'
`-m'
     These options are ignored for compatibility with other versions
     of `make'.

`-C DIR'
     Change to directory DIR before reading the makefiles.  If multiple
     `-C' options are specified, each is interpreted relative to the
     previous one: `-C / -C etc' is equivalent to `-C /etc'.  This is
     typically used with recursive invocations of `make' (*note
     Recursion::.).

`-d'
     Print debugging information in addition to normal processing.  The
     debugging information says which files are being considered for
     remaking, which file-times are being compared and with what
     results, which files actually need to be remade, which implicit
     rules are considered and which are applied--everything
     interesting about how `make' decides what to do.

`-e'
     Give variables taken from the environment precedence over
     variables from makefiles.  *Note Environment::.

`-f FILE'
     Use file FILE as a makefile.  *Note Makefiles::.

`-i'
     Ignore all errors in commands executed to remake files.  *Note
     Errors::.

`-I DIR'
     Specifies a directory DIR to search for included makefiles. 
     *Note Include::.  If several `-I' options are used to specify
     several directories, the directories are searched in the order
     specified.  Unlike the arguments to other flags of `make',
     directories given with `-I' flags may come directly after the
     flag: `-IDIR' is allowed, as well as `-I DIR'.  This syntax is
     allowed for compatibility with the C preprocessor's `-I' flag.

`-j JOBS'
     Specifies the number of jobs (commands) to run simultaneously.  If
     there is more than one `-j' option, the last one is effective. 
     *Note Execution::, for more information on how commands are run.

`-k'
     Continue as much as possible after an error.  While the target
     that failed, and those that depend on it, cannot be remade, the
     other dependencies of these targets can be processed all the same. 
     *Note Testing::.

`-l LOAD'
`-l'
     Specifies that no new jobs (commands) should be started if there
     are others jobs running and the load average is at least LOAD (a
     floating-point number).  With no argument, removes a previous load
     limit.  *Note Parallel::.

`-n'
     Print the commands that would be executed, but do not execute
     them.  *Note Instead of Execution::.

`-o FILE'
     Do not remake the file FILE even if it is older than its
     dependencies, and do not remake anything on account of changes in
     FILE.  Essentially the file is treated as very old and its rules
     are ignored.  *Note Avoiding Compilation::.

`-p'
     Print the data base (rules and variable values) that results from
     reading the makefiles; then execute as usual or as otherwise
     specified.  This also prints the version information given by the
     `-v' switch (see below).  To print the data base without trying
     to remake any files, use `make -p -f /dev/null'.

`-q'
     "Question mode".  Do not run any commands, or print anything; just
     return an exit status that is zero if the specified targets are
     already up to date, nonzero otherwise.  *Note Instead of
     Execution::.

`-r'
     Eliminate use of the built-in implicit rules (*note Implicit::.). 
     Also clear out the default list of suffixes for suffix rules
     (*note Suffix Rules::.).

`-s'
     Silent operation; do not print the commands as they are executed. 
     *Note Echoing::.

`-S'
     Cancel the effect of the `-k' option.  This is never necessary
     except in a recursive `make' where `-k' might be inherited from
     the top-level `make' via `MAKEFLAGS' (*note Recursion::.) or if
     you set `-k' in `MAKEFLAGS' in your environment.

`-t'
     Touch files (mark them up to date without really changing them)
     instead of running their commands.  This is used to pretend that
     the commands were done, in order to fool future invocations of
     `make'.  *Note Instead of Execution::.

`-v'
     Print the version of the `make' program plus a copyright, a list
     of authors and a notice that there is no warranty.  After this
     information is printed, processing continues normally.  To get
     this information without doing anything else, use `make -v -f
     /dev/null'.

`-w'
     Print a message containing the working directory both before and
     after executing the makefile.  This may be useful for tracking
     down errors from complicated nests of recursive `make' commands. 
     *Note Recursion::.

`-W FILE'
     Pretend that the target FILE has just been modified.  When used
     with the `-n' flag, this shows you what would happen if you were
     to modify that file.  Without `-n', it is almost the same as
     running a `touch' command on the given file before running
     `make', except that the modification time is changed only in the
     imagination of `make'.


File: make.info,  Node: Implicit,  Next: Archives,  Prev: Running,  Up: Top

Using Implicit Rules
********************

   Certain standard ways of remaking target files are used very often.
 For example, one customary way to make an object file is from a C
source file using the C compiler, `cc'.

   "Implicit rules" tell `make' how to use customary techniques so
that you don't have to specify them in detail when you want to use
them.  For example, there is an implicit rule for C compilation. 
Implicit rules work based on file names.  For example, C compilation
typically takes a `.c' file and makes a `.o' file.  So `make' applies
the implicit rule for C compilation when it sees this combination of
file-name endings.

   A chain of implicit rules can apply in sequence; for example, `make'
will remake a `.o' file from a `.y' file by way of a `.c' file.

   The built-in implicit rules use several variables in their commands
so that, by changing the values of the variables, you can change the
way the implicit rule works.  For example, the variable `CFLAGS'
controls the flags given to the C compiler by the implicit rule for C
compilation.

   You can define your own implicit rules by writing "pattern rules".

* Menu:

* Using Implicit::       How to use an existing implicit rule
                          to get the commands for updating a file.

* Catalogue of Rules::   Catalogue of built-in implicit rules.

* Implicit Variables::   By changing certain variables, you can
                          change what the predefined implicit rules do.

* Chained Rules::        Using a chain of implicit rules.

* Pattern Rules::        Defining new implicit rules.

* Last Resort::          Defining commands for rules which can't find any.

* Suffix Rules::         The old-fashioned style of implicit rule.

* Search Algorithm::     Precise algorithm for applying implicit rules.


File: make.info,  Node: Using Implicit,  Next: Catalogue of Rules,  Prev: Implicit,  Up: Implicit

Using Implicit Rules
====================

   To allow `make' to find a customary method for updating a target
file, all you have to do is refrain from specifying commands yourself.
 Either write a rule with no command lines, or don't write a rule at
all.  Then `make' will figure out which implicit rule to use based on
which kind of source file exists.

   For example, suppose the makefile looks like this:

     foo : foo.o bar.o
             cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)

Because you mention `foo.o' but do not give a rule for it, `make' will
automatically look for an implicit rule that tells how to update it. 
This happens whether or not the file `foo.o' currently exists.

   If an implicit rule is found, it supplies both commands and one or
more dependencies (the source files).  You would want to write a rule
for `foo.o' with no command lines if you need to specify additional
dependencies, such as header files, that the implicit rule cannot
supply.

   Each implicit rule has a target pattern and dependency patterns. 
There may be many implicit rules with the same target pattern.  For
example, numerous rules make `.o' files: one, from a `.c' file with
the C compiler; another, from a `.p' file with the Pascal compiler;
and so on.  The rule that actually applies is the one whose
dependencies exist or can be made.  So, if you have a file `foo.c',
`make' will run the C compiler; otherwise, if you have a file `foo.p',
`make' will run the Pascal compiler; and so on.

   Of course, when you write the makefile, you know which implicit
rule you want `make' to use, and you know it will choose that one
because you know which possible dependency files are supposed to exist. 
*Note Catalogue of Rules::, for a catalogue of all the predefined
implicit rules.

   Above, we said an implicit rule applies if the required
dependencies "exist or can be made".  A file "can be made" if it is
mentioned explicitly in the makefile as a target or a dependency, or
if an implicit rule can be recursively found for how to make it.  When
an implicit dependency is the result of another implicit rule, we say
that "chaining" is occurring.  *Note Chained Rules::.

   In general, `make' searches for an implicit rule for each target,
and for each double-colon rule, that has no commands.  A file that is
mentioned only as a dependency is considered a target whose rule
specifies nothing, so implicit rule search happens for it.  *Note
Search Algorithm::, for the details of how the search is done.

   If you don't want an implicit rule to be used for a target that has
no commands, you can give that target empty commands by writing a
semicolon.  *Note Empty Commands::.


File: make.info,  Node: Catalogue of Rules,  Next: Implicit Variables,  Prev: Using Implicit,  Up: Implicit

Catalogue of Implicit Rules
===========================

   Here is a catalogue of predefined implicit rules which are always
available unless the makefile explicitly overrides or cancels them. 
*Note Canceling Rules::, for information on canceling or overriding an
implicit rule.  The `-r' option cancels all predefined rules.

   Not all of these rules will always be defined, even when the `-r'
option is not given.  Many of the predefined implicit rules are
implemented in `make' as suffix rules, so which ones will be defined
depends on the "suffix list" (the list of dependencies of the special
target `.SUFFIXES').  *Note Suffix Rules::.  The default suffix list
is: `.out', `.a', `.o', `.c', `.cc', `.C', `.p', `.f', `.F', `.r',
`.e', `.y', `.ye', `.yr', `.l', `.s', `.S', `.h', `.info', `.dvi',
`.tex', `.texinfo', `.cweb', `.web', `.sh', `.elc', `.el'. All of the
implicit rules described below whose dependencies have one of these
suffixes are actually suffix rules.  If you modify the suffix list,
the only predefined suffix rules in effect will be those named by one
or two of the suffixes that are on the list you specify; rules whose
suffixes fail to be on the list are disabled.

Compiling C programs
     `N.o' will be made automatically from `N.c' with a command of the
     form `$(CC) -c $(CPPFLAGS) $(CFLAGS)'.

Compiling C++ programs
     `N.o' will be made automatically from `N.cc' or `N.C' with a
     command of the form `$(C++) -c $(CPPFLAGS) $(C++FLAGS)'.  We
     encourage you to use the suffix `.cc' for C++ source files
     instead of `.C'.

Compiling Pascal programs
     `N.o' will be made automatically from `N.p' with the command
     `$(PC) -c $(PFLAGS)'.

Compiling Fortran and Ratfor programs
     `N.o' will be made automatically from `N.r', `N.F' or `N.f' by
     running the Fortran compiler.  The precise command used is as
     follows:

    `.f'
          `$(FC) -c $(FFLAGS)'.

    `.F'
          `$(FC) -c $(FFLAGS) $(CPPFLAGS)'.

    `.r'
          `$(FC) -c $(FFLAGS) $(RFLAGS)'.

Preprocessing Fortran and Ratfor programs
     `N.f' will be made automatically from `N.r' or `N.F'.  This rule
     runs just the preprocessor to convert a Ratfor or preprocessable
     Fortran program into a strict Fortran program.  The precise
     command used is as follows:

    `.F'
          `$(FC) -F $(CPPFLAGS) $(FFLAGS)'.

    `.r'
          `$(FC) -F $(FFLAGS) $(RFLAGS)'.

Compiling Modula-2 programs
     `N.sym' will be made from `N.def' with a command of the form
     `$(M2C) $(M2FLAGS) $(DEFFLAGS)'.  `N.o' will be made from `N.mod'
     with a command of the form `$(M2C) $(M2FLAGS) $(MODFLAGS)'.

Assembling and preprocessing assembler programs
     `N.o' will be made automatically from `N.s' by running the
     assembler `as'.  The precise command used is `$(AS) $(ASFLAGS)'.

     `N.s' will be made automatically from `N.S' by running the C
     preprocessor `cpp'.  The precise command used is `$(CPP)
     $(CPPFLAGS)'.

Linking a single object file
     `N' will be made automatically from `N.o' by running the linker
     `ld' via the C compiler.  The precise command used is `$(CC)
     $(LDFLAGS) N.o $(LOADLIBES)'.

     This rule does the right thing for a simple program with only one
     source file.  It will also do the right thing if there are
     multiple object files (presumably coming from various other
     source files), the first of which has a name matching that of the
     executable file.  Thus,

          x: y.o z.o

          when `x.c', `y.c' and `z.c' all exist will execute:

          cc -c x.c -o x.o
          cc -c y.c -o y.o
          cc -c z.c -o z.o
          cc x.o y.o z.o -o x
          rm -f x.o
          rm -f y.o
          rm -f z.o

          In more complicated cases, such as when there is no object file
     whose name derives from the executable file name, you must write
     an explicit command for linking.

     Each kind of file automatically made into `.o' object files will
     be automatically linked by using the compiler (`$(CC)', `$(FC)'
     or `$(PC)'; the C compiler `$(CC)' is used to assemble `.s'
     files) without the `-c' option.  This could be done by using the
     `.o' object files as intermediates, but it is faster to do the
     compiling and linking in one step, so that's how it's done.

Yacc for C programs
     `N.c' will be made automatically from `N.y' by running Yacc with
     the command `$(YACC) $(YFLAGS)'.

Lex for C programs
     `N.c' will be made automatically from `N.l' by by running Lex. 
     The actual command is `$(LEX) $(LFLAGS)'.

Lex for Ratfor programs
     `N.r' will be made automatically from `N.l' by by running Lex. 
     The actual command is `$(LEX) $(LFLAGS)'.

     The convention of using the same suffix `.l' for all Lex files
     regardless of whether they produce C code or Ratfor code makes it
     impossible for `make' to determine automatically which of the two
     languages you are using in any particular case.  If `make' is
     called upon to remake an object file from a `.l' file, it must
     guess which compiler to use.  It will guess the C compiler,
     because that is more common.  If you are using Ratfor, make sure
     `make' knows this by mentioning `N.r' in the makefile.  Or, if you
     are using Ratfor exclusively, with no C files, remove `.c' from
     the list of implicit rule suffixes with:

          .SUFFIXES:
          .SUFFIXES: .r .f .l ...

Making Lint Libraries from C, Yacc, or Lex programs
     `N.ln' will be made from `N.c' with a command of the form
     `$(LINT) $(LINTFLAGS) $(CPPFLAGS) -i'.  The same command will be
     used on the C code produced from `N.y' or `N.l'.

TeX and Web
     `N.dvi' will be made from `N.tex' with the command `$(TEX)'. 
     `N.tex' will be made from `N.web' with `$(WEAVE)', or from
     `N.cweb' with `$(CWEAVE)'.  `N.p' will be made from `N.web' with
     `$(TANGLE)' and `N.c' will be made from `N.cweb' with
     `$(CTANGLE)'.

Texinfo and Info
     `N.dvi' will be made from `N.texinfo' using the `$(TEX)' and
     `$(TEXINDEX)' commands.  The actual command sequence contains
     many shell conditionals to avoid unnecessarily running TeX twice
     and to create the proper sorted index files.  `N.info' will be
     made from `N.texinfo' with the command `$(MAKEINFO)'.

RCS
     Any file `N' will be extracted if necessary from an RCS file
     named either `N,v' or `RCS/N,v'.  The precise command used is
     `$(CO) $(COFLAGS)'.  `N' will not be extracted from RCS if it
     already exists, even if the RCS file is newer.

SCCS
     Any file `N' will be extracted if necessary from an SCCS file
     named either `s.N' or `SCCS/s.N'.  The precise command used is
     `$(GET) $(GFLAGS)'.

     For the benefit of SCCS, a file `N' will be copied from `N.sh'
     and made executable (by everyone).  This is for shell scripts
     that are checked into SCCS.  Since RCS preserves the execution
     permission of a file, you don't need to use this feature with RCS.

     We recommend that you avoid the use of SCCS.  RCS is widely held
     to be superior, and is also free.  By choosing free software in
     place of comparable (or inferior) proprietary software, you
     support the free software movement.


File: make.info,  Node: Implicit Variables,  Next: Chained Rules,  Prev: Catalogue of Rules,  Up: Implicit

Variables Used by Implicit Rules
================================

   The commands in built-in implicit rules make liberal use of certain
predefined variables.  You can alter these variables, either in the
makefile or with arguments to `make', to alter how the implicit rules
work without redefining the rules themselves.

   For example, the command used to compile a C source file actually
says `$(CC) -c $(CFLAGS) $(CPPFLAGS)'.  The default values of the
variables used are `cc' and nothing, resulting in the command `cc -c'.
 By redefining `$(CC)' to `ncc', you could cause `ncc' to be used for
all C compilations performed by the implicit rule.  By redefining
`$(CFLAGS)' to be `-g', you could pass the `-g' option to each
compilation.  *All* implicit rules that do C compilation use `$(CC)'
to get the program name for the compiler and *all* include `$(CFLAGS)'
among the arguments given to the compiler.

   The variables used in implicit rules fall into two classes: those
that are names of programs (like `CC') and those that contain
arguments for the programs (like `CFLAGS').  (The "name of a program"
may also contain some command arguments, but it must start with an
actual executable program name.)  If a variable value contains more
than one argument, separate them with spaces.

   Here is a table of variables used as names of programs:

`AR'
     Archive-maintaing program; default `ar'.

`AS'
     Program for doing assembly; default `as'.

`CC'
     Program for compiling C programs; default `cc'.

`C++'
     Program for compiling C++ programs; default `g++'.

`CO'
     Program for extracting a file from RCS; default `co'.

`CPP'
     Program for running the C preprocessor, with results to standard
     output; default `$(CC) -E'.

`FC'
     Program for compiling or preprocessing Fortran, Ratfor, and EFL
     programs; default `f77'.

`GET'
     Program for extracting a file from SCCS; default `get'.

`LEX'
     Program to use to turn Lex grammars into C programs or Ratfor
     programs; default `lex'.

`PC'
     Program for compiling Pascal programs; default `pc'.

`FC'
`EC'
`RC'
     Programs for compiling Fortran, EFL, and Ratfor programs,
     respectively; these all default to `f77'.

`YACC'
     Program to use to turn Yacc grammars into C programs; default
     `yacc'.

`YACCR'
     Program to use to turn Yacc grammars into Ratfor programs;
     default `yacc -r'.

`YACCE'
     Program to use to turn Yacc grammars into EFL programs; default
     `yacc -e'.

`MAKEINFO'
     Program to make Info files from Texinfo source; default
     `makeinfo'.

`TEX'
     Program to make TeX DVI files from TeX or Texinfo source; default
     `tex'.

`TEXINDEX'
     The `texindex' program distributed with Emacs.  This is used in
     the process to make TeX DVI files from Texinfo source.

`WEAVE'
     Program to translate Web into TeX; default `weave'.

`CWEAVE'
     Program to translate C Web into TeX; default `cweave'.

`TANGLE'
     Program to translate Web into Pascal; default `tangle'.

`CTANGLE'
     Program to translate C Web into C; default `ctangle'.

`RM'
     Command to remove a file; default `rm -f'.

   Here is a table of variables whose values are additional arguments
for the programs above.  The default values for all of these is the
empty string, unless otherwise noted.

`ARFLAGS'
     Flags to give the archive- maintaining program; default `rv'.

`ASFLAGS'
     Extra flags to give to the assembler (when explicitly invoked on
     a `.s' file).

`CFLAGS'
     Extra flags to give to the C compiler.

`C++FLAGS'
     Extra flags to give to the C++ compiler.

`COFLAGS'
     Extra flags to give to the RCS `co' program.

`CPPFLAGS'
     Extra flags to give to the C preprocessor and programs that use
     it (the C and Fortran compilers).

`EFLAGS'
     Extra flags to give to the Fortran compiler for EFL programs.

`FFLAGS'
     Extra flags to give to the Fortran compiler.

`GFLAGS'
     Extra flags to give to the SCCS `get' program.

`LDFLAGS'
     Extra flags to give to compilers when they are supposed to invoke
     the linker, `ld'.

`LFLAGS'
     Extra flags to give to Lex.

`PFLAGS'
     Extra flags to give to the Pascal compiler.

`RFLAGS'
     Extra flags to give to the Fortran compiler for Ratfor programs.

`YFLAGS'
     Extra flags to give to Yacc.


File: make.info,  Node: Chained Rules,  Next: Pattern Rules,  Prev: Implicit Variables,  Up: Implicit

Chains of Implicit Rules
========================

   Sometimes a file can be made by a sequence of implicit rules.  For
example, a file `N.o' could be made from `N.y' by running first Yacc
and then `cc'.  Such a sequence is called a "chain".

   If the file `N.c' exists, or is mentioned in the makefile, no
special searching is required: `make' finds that the object file can
be made by C compilation from `N.c'; later on, when considering how to
make `N.c', the rule for running Yacc will be used.  Ultimately both
`N.c' and `N.o' are updated.

   However, even if `N.c' does not exist and is not mentioned, `make'
knows how to envision it as the missing link between `N.o' and `N.y'! 
In this case, `N.c' is called an "intermediate file".  Once `make' has
decided to use the intermediate file, it is entered in the data base
as if it had been mentioned in the makefile, along with the implicit
rule that says how to create it.

   Intermediate files are remade using their rules just like all other
files.  The difference is that the intermediate file is deleted when
`make' is finished.  Therefore, the intermediate file which did not
exist before `make' also does not exist after `make'.  The deletion is
reported to you by printing a `rm -f' command that shows what `make'
is doing.  (You can optionally define an implicit rule so as to
preserve certain intermediate files.  You can also list the target
pattern of an implicit rule (such as `%.o') as a dependency file of
the special target `.PRECIOUS' to preserve intermediate files whose
target patterns match that file's name.)

   A chain can involve more than two implicit rules.  For example, it
is possible to make a file `foo' from `RCS/foo.y,v' by running RCS,
Yacc and `cc'.  Then both `foo.y' and `foo.c' are intermediate files
that are deleted at the end.

   No single implicit rule can appear more than once in a chain.  This
means that `make' will not even consider such a ridiculous thing as
making `foo' from `foo.o.o' by running the linker twice.  This
constraint has the added benefit of preventing any infinite loop in the
search for an implicit rule chain.

   There are some special implicit rules to optimize certain cases
that would otherwise by handled by rule chains.  For example, making
`foo' from `foo.c' could be handled by compiling and linking with
separate chained rules, using `foo.o' as an intermediate file.  But
what actually happens is that a special rule for this case does the
compilation and linking with a single `cc' command.  The optimized
rule is used in preference to the step-by-step chain because it comes
earlier in the ordering of rules.


File: make.info,  Node: Pattern Rules,  Next: Last Resort,  Prev: Chained Rules,  Up: Implicit

Defining and Redefining Pattern Rules
=====================================

   You define an implicit rule by writing a "pattern rule".  A pattern
rule looks like an ordinary rule, except that its target contains the
character `%' (exactly one of them).  The target is considered a
pattern for matching file names; the `%' can match any nonempty
substring, while other characters match only themselves.  The
dependencies likewise use `%' to show how their names relate to the
target name.

   Thus, a pattern rule `%.o : %.c' says how to make any file `STEM.o'
from another file `STEM.c'.

* Menu:

* Intro: Pattern Intro.        Basics of writing pattern rules.
* Examples: Pattern Examples.  Real examples of pattern rule definitions.

* Vars: Automatic.             The automatic variables enable the commands
                                in pattern rules to act on the right files.

* Matching: Pattern Match.     Details of how patterns match.

* Match-Anything Rules::       Precautions in defining a rules that can
                                match any target file whatever.

* Canceling Rules::            Overriding or canceling built-in rules.

* Last Resort::                How to define a last-resort rule
                                that applies to any target that no other
                                rule applies to.

* Suffix Rules::               The old-fashioned way to define implicit rules.

