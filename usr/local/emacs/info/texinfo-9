This is Info file texinfo, produced by Makeinfo-1.43 from the input
file texinfo2.texi.

   This file documents Texinfo, a documentation system that uses a
single source file to produce both on-line information and a printed
manual.

   This is edition 2.14 of the Texinfo documentation,
14 February 1992, for Texinfo version 2.

   Copyright (C) 1988, 1990, 1991, 1992 Free Software Foundation, Inc.

   This is the second edition of the Texinfo documentation,
 and is consistent with version 2 of `texinfo.tex'.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: texinfo,  Node: Custom Headings,  Prev: Heading Choice,  Up: Headings

How to Make Your Own Headings
=============================

   You can use the standard headings provided with Texinfo or specify
your own.

   Texinfo provides six commands for specifying headings and footings. 
The `@everyheading' and `@everyfooting' commands generate headers and
footers that are the same for both even- and odd-numbered pages.  The
`@evenheading' and `@evenfooting' commands generate headers and
footers for even-numbered (left-hand) pages; and the `@oddheading' and
`@oddfooting' commands generate headers and footers for odd-numbered
(right-hand) pages.

   Write custom heading specifications in the Texinfo file immediately
after the `@end titlepage' command.  Enclose your specifications
between `@iftex' and `@end iftex' commands since the
`texinfo-format-buffer' command may not recognize them.  Also, you
must cancel the predefined heading commands with the `@headings off'
command before defining your own specifications.

   Here is how to tell TeX to place the chapter name at the left, the
page number in the center, and the date at the right of every header
for both even- and odd-numbered pages:

     @iftex
     @headings off
     @everyheading @thischapter @| @thispage @| @today{}
     @end iftex

You need to divide the left part from the central part and the central
part from the right had part by inserting `@|' between parts. 
Otherwise, the specification command will not be able to tell where
the text for one part ends and the next part begins.

   Each part can contain text or `@this...' commands.  The text is
printed as if the part were within an ordinary paragraph in the body
of the page.  The `@this...' commands replace themselves with the page
number, date, chapter name, or whatever.

   Here are the six heading and footing commands:

`@everyheading LEFT @| CENTER @| RIGHT'
`@everyfooting LEFT @| CENTER @| RIGHT'
     The `every' commands specify the format for both even- and
     odd-numbered pages.  These commands are for documents that are
     printed on one side of each sheet of paper, or for documents in
     which you want symmetrical headers or footers.

`@evenheading LEFT @| CENTER @| RIGHT'
`@oddheading  LEFT @| CENTER @| RIGHT'
`@evenfooting LEFT @| CENTER @| RIGHT'
`@oddfooting  LEFT @| CENTER @| RIGHT'
     The `even' and `odd' commands specify the format for even-numbered
     pages and odd-numbered pages.  These commands are for books and
     manuals that are printed on both sides of each sheet of paper.

   Use the `@this...' commands to provide the names of chapters and
sections and the page number.  You can use the `@this...' commands in
the left, center, or right portions of headers and footers, or
anywhere else in a Texinfo file so long as they are between `@iftex'
and `@end iftex' commands.

   Here are the `@this...' commands:

`@thispage'
     Expands to the current page number.

`@thischaptername'
     Expands to the name of the current chapter.

`@thischapter'
     Expands to the number and name of the current chapter, in the
     format `Chapter 1: First Chapter'.

`@thistitle'
     Expands to the name of the document, as specified by the
     `@settitle' command.

`@thisfile'
     For `@include' files only: expands to the name of the current
     `@include' file.  If the current Texinfo source file is not an
     `@include' file, this command has no effect.  This command does
     *not* provide the name of the current Texinfo source file unless
     it is an `@include' file.  (*Note Include Files::, for more
     information about `@include' files.)

You can also use the `@today{}' command, which expands to the current
date, in `1 Jan 1900' format.

   Other @-commands and text are printed in a header or footer just as
if they were in the body of a page.  It is useful to incorporate text,
particularly when you are writing drafts:

     @iftex
     @headings off
     @everyheading @emph{Draft!} @| @thispage @| @thischapter
     @everyfooting @| @| Version: 0.27: @today{}
     @end iftex

   Beware of overlong titles: they may overlap another part of the
header or footer and blot it out.


File: texinfo,  Node: Catching Mistakes,  Next: Refilling Paragraphs,  Prev: Headings,  Up: Top

Formatting Mistakes
*******************

   Besides mistakes in the content of your documentation, there are
two kinds of mistake you can make with Texinfo:  you can make mistakes
with @-commands, and you can make mistakes with the structure of the
nodes and chapters.

   Emacs has two tools for catching the @-command mistakes and two for
catching structuring mistakes.

   For finding problems with @-commands, you can run TeX or a region
formatting command on the region that has a problem; indeed, you can
run these commands on each region as you write it.

   For finding problems with the structure of nodes and chapters, you
can use `C-c C-s' (`texinfo-show-structure') (and the related `occur'
command) and you can use the `M-x Info-validate' command.

* Menu:

* makeinfo preferred::          `makeinfo' finds errors.
* Debugging with Info::         How to catch errors with Info formatting.
* Debugging with TeX::          How to catch errors with TeX formatting.
* Using texinfo-show-structure::  How to use `texinfo-show-structure'.
* Using occur::                 How to list all lines containing a pattern.
* Running Info-Validate::       How to find badly referenced nodes.


File: texinfo,  Node: makeinfo preferred,  Next: Debugging with Info,  Prev: Catching Mistakes,  Up: Catching Mistakes

`makeinfo' Find Errors
======================

   The `makeinfo' program does an excellent job of catching errors and
reporting them--far better than `texinfo-format-region' or
`texinfo-format-buffer'.  In addition, the various functions for
automatically creating and updating node pointers and menus remove
many opportunities for human error.

   If you can, use the updating commands to create and insert pointers
and menus.  These prevent many errors.  Then use `makeinfo' (or its
Texinfo mode manifestations, `makeinfo-region' and `makeinfo-buffer')
to format your file and check for other errors.  This is the best way
to work with Texinfo.  But if you cannot use `makeinfo', or your
problem is very puzzling, then you may want to use the tools described
in this appendix.


File: texinfo,  Node: Debugging with Info,  Next: Debugging with TeX,  Prev: makeinfo preferred,  Up: Catching Mistakes

Catching Errors with Info Formatting
====================================

   After you have written part of a Texinfo file, you can use the
`texinfo-format-region' or the `makeinfo-region' command to see
whether the region formats properly.

   Most likely, however, you are reading this section because for some
reason you cannot use the `makeinfo-region' command; therefore, the
rest of this section presumes that you are using
`texinfo-format-region'.

   If you have made a mistake with an @-command,
`texinfo-format-region' will stop processing at or after the error and
display an error message.  To see where in the buffer the error
occurred, switch to the `*Info Region*' buffer; the cursor will be in
a position that is after the location of the error.  Also, the text
will not be formatted after the place where the error occurred (or
more precisely, where it was detected).

   For example, if you accidentally end a menu with the command `@end
menus' with an `s' on the end, instead of with `@end menu', you will
see an error message that says:

     @end menus is not handled by texinfo

The cursor will stop at the point in the buffer where the error
occurs, or not long after it.  The buffer will look like this:

     ---------- Buffer: *Info Region* ----------
     * Menu:
     
     * Using texinfo-show-structure::  How to use
                                       `texinfo-show-structure'
                                       to catch mistakes.
     * Running Info-Validate::         How to check for
                                       unreferenced nodes.
     @end menus
     -!-
     ---------- Buffer: *Info Region* ----------

   The `texinfo-format-region' command sometimes provides slightly odd
error messages.  For example,

     (@xref{Catching Mistakes, for more info.)

In this case, `texinfo-format-region' detects the missing closing
brace but displays a message that says `Unbalanced parentheses' rather
than `Unbalanced braces'.  This is because the formatting command
looks for mismatches between braces as if they were parentheses.

   Sometimes `texinfo-format-region' fails to detect mistakes.  For
example, in the following, the closing brace is swapped with the
closing parenthesis:

     (@xref{Catching Mistakes), for more info.}

Formatting produces:
     (*Note for more info.: Catching Mistakes)

   The only way for you to detect this error is to realize that the
reference should have looked like this:

     (*Note Catching Mistakes::, for more info.)

   Incidentally, if you are reading this node in Info and type `f RET'
(`Info-follow-reference'), you will generate an error message that
says:

     No such node: "Catching Mistakes) The only way ...

This is because Info perceives the example of the error as the first
cross reference in this node and if you type a RET immediately after
typing the Info `f' command, Info will attempt to go to the referenced
node.  If you type `f catch TAB RET', Info will complete the node name
of the correctly written example and take you to the `Catching
Mistakes' node.  (If you try this, you can return from the `Catching
Mistakes' node by typing `l' (`Info-last').)


File: texinfo,  Node: Debugging with TeX,  Next: Using texinfo-show-structure,  Prev: Debugging with Info,  Up: Catching Mistakes

Catching Errors with TeX Formatting
===================================

   You can also catch mistakes when you format a file with TeX.

   Usually, you will want to do this after you have run
`texinfo-format-buffer' (or, better, `makeinfo-buffer') on the same
file, because `texinfo-format-buffer' sometimes displays error
messages that make more sense than TeX.  (*Note Debugging with Info::,
for more information.)

   For example, TeX was run on a Texinfo file, part of which is shown
here:

     ---------- Buffer: texinfo.texi ----------
     name of the texinfo file as an extension.  The
     @samp{??} are `wildcards' that cause the shell to
     substitute all the raw index files.  (@xref{sorting
     indices, for more information about sorting
     indices.)@refill
     ---------- Buffer: texinfo.texi ----------

(The cross reference lacks a closing brace.) TeX produced the
following output, after which it stopped:

     ---------- Buffer: *texinfo-tex-shell* ----------
     Runaway argument?
     {sorting indices, for more information about sorting
     indices.) @refill @ETC.
     ! Paragraph ended before \xref was complete.
     <to be read again>
                        \par
     l.27
     
     ?
     ---------- Buffer: *texinfo-tex-shell* ----------

   In this case, TeX produced an accurate and understandable error
message:

     Paragraph ended before \xref was complete.

(Note, however, that TeX translated the `@' into a `\'.)  Also, `\par'
is an internal TeX command of no relevance to Texinfo.)

   Unfortunately, TeX is not always so helpful, and sometimes you have
to be truly a Sherlock Holmes to discover what went wrong.

   In any case, if you run into a problem like this, you can do one of
two things.

  1. You can tell TeX to continue running and to ignore errors as best
     it can by typing `r RET' at the `?' prompt.

        This is often the best thing to do.  However, beware: the one
     error may produce a cascade of additional error messages as its
     consequences are felt through the rest of the file.  (To stop TeX
     when it is producing such an avalanche of error messages, type
     `C-d' (or `C-c C-d', if you running a shell inside Emacs.))

  2. You can tell TeX to stop this run by typing `x RET' at the `?'
     prompt.

   Sometimes TeX will format a file without producing error messages
even though there is a problem.  This usually occurs if a command is
not ended but TeX is able to continue processing anyhow.  For example,
if you fail to end an itemized list with the `@end itemize' command,
TeX will write a DVI file that you can print out.  The only error
message that TeX will give you is the somewhat mysterious comment that

     (\end occurred inside a group at level 1)

However, if you print the DVI file, you will find that the text of the
file that follows the itemized list is entirely indented as if it were
part of the last item in the itemized list.  The error message is the
way TeX says that it expected to find an `@end' command somewhere in
the file; but that it could not determine where it was needed.

   Another source of notoriously hard-to-find errors is a missing
`@end group' command.  If you ever are stumped by incomprehensible
errors, look for a missing `@end group' command first.

   If you do not have the header lines in the file, TeX may stop in the
beginning of its run and display output that looks like the following. 
The `*' indicates that TeX is waiting for input.

     This is TeX, Version 2.0 for Berkeley UNIX
     (preloaded format=plain-cm 87.10.25)
     (test.texinfo [1])
     *

In this case, simply type `\end RET' after the asterisk.  Then put the
header lines into the Texinfo file and run the TeX command again.


File: texinfo,  Node: Using texinfo-show-structure,  Next: Using occur,  Prev: Debugging with TeX,  Up: Catching Mistakes

Using `texinfo-show-structure'
==============================

   It is not always easy to keep track of the nodes, chapters,
sections, and subsections of a Texinfo file.  This is especially true
if you are revising or adding to a Texinfo file that someone else has
written.

   In GNU Emacs, in Texinfo mode, the `texinfo-show-structure' command
lists all the lines that begin with the @-commands that specify the
structure: `@chapter', `@section', `@appendix', and so on.  With an
argument (prefix, if interactive), the command also shows the `@node'
lines.  The `texinfo-show-structure' command is bound to `C-c C-s' in
Texinfo mode, by default.

   The lines are displayed in a buffer called the `*Occur*' buffer. 
For example, when `texinfo-show-structure' was run on an earlier
version of this appendix, it produced the following:

     Lines matching "^@\\(chapter \\|sect\\|sub\\|unnum\\|major\\|
     heading \\|appendix\\)" in buffer texinfo.texi.
       4:@appendix Formatting Mistakes
      52:@appendixsec Catching Errors with Info Formatting
     222:@appendixsec Catching Errors with @TeX{} Formatting
     338:@appendixsec Using @code{texinfo-show-structure}
     407:@appendixsubsec Using @code{occur}
     444:@appendixsec Finding Badly Referenced Nodes
     513:@appendixsubsec Running @code{Info-validate}
     573:@appendixsubsec Splitting a File Manually

   This says that lines 4, 52, and 222 of `texinfo.texi' begin with
the `@appendix', `@appendixsec', and `@appendixsec' commands
respectively.  If you move your cursor into the `*Occur*' window, you
can position the cursor over one of the lines and use the `C-c C-c'
command (`occur-mode-goto-occurrence'), to jump to the corresponding
spot in the Texinfo file.  *Note Using Occur: (emacs)Other Repeating
Search, for more information about `occur-mode-goto-occurrence'.

   The first line in the `*Occur*' window describes the "regular
expression" specified by TEXINFO-HEADING-PATTERN.  This regular
expression is the pattern that `texinfo-show-structure' looks for. 
*Note Using Regular Expressions: (emacs)Regexps, for more information.

   When you invoke the `texinfo-show-structure' command, Emacs will
display the structure of the whole buffer.  If you want to see the
structure of just a part of the buffer, of one chapter, for example,
use the `C-x n' (`narrow-to-region') command to mark the region. 
(*Note Narrowing: (emacs)Narrowing.)  This is how the example used
above was generated.  (To see the whole buffer again, use `C-x w'
(`widen').)

   If you call `texinfo-show-structure' with a prefix argument by
typing `C-u C-c C-s', it will list lines beginning with `@node' as
well as the lines beginning with the @-sign commands for `@chapter',
`@section', and the like.

   You can remind yourself of the structure of a Texinfo file by
looking at the list in the `*Occur*' window; and if you have mis-named
a node or left out a section, you can correct the mistake.


File: texinfo,  Node: Using occur,  Next: Running Info-Validate,  Prev: Using texinfo-show-structure,  Up: Catching Mistakes

Using `occur'
=============

   Sometimes the `texinfo-show-structure' command produces too much
information.  Perhaps you want to remind yourself of the overall
structure of a Texinfo file, and are overwhelmed by the detailed list
produced by `texinfo-show-structure'.  In this case, you can use the
`occur' command directly.  To do this, type

     `M-x occur'

and then, when prompted, type a "regexp", a regular expression for the
pattern you want to match.  (*Note Regular Expressions: (
emacs)Regexps.)  The `occur' command works from the current location
of the cursor in the buffer to the end of the buffer.  If you want to
run `occur' on the whole buffer, place the cursor at the beginning of
the buffer.

   For example, to see all the lines that contain the word `@chapter'
in them, just type `@chapter'.  This will produce a list of the
chapters.  It will also list all the sentences with `@chapter' in the
middle of the line.

   If you want to see only those lines that start with the word
`@chapter', type `^@chapter' when prompted by `occur'.  If you want to
see all the lines that end with a word or phrase, end the last word
with a `$'; for example, `catching mistakes$'.  This can be helpful
when you want to see all the nodes that are part of the same chapter
or section and therefore have the same `Up' pointer.

   *Note Using Occur: (emacs)Other Repeating Search, for more
information.


File: texinfo,  Node: Running Info-Validate,  Prev: Using occur,  Up: Catching Mistakes

Finding Badly Referenced Nodes
==============================

   You can use the `Info-validate' command to check whether any of the
`Next', `Previous', `Up' or other node pointers fail to point to a
node.  This command checks that every node pointer points to an
existing node.  The `Info-validate' command works only on Info files,
not on Texinfo files.

   The `makeinfo' program validates pointers automatically, so you do
not need to use the `Info-validate' command if you are using
`makeinfo'.  You only may need to use `Info-validate' if you are
unable to run `makeinfo' and instead must create an Info file using
`texinfo-format-region' or `texinfo-format-buffer', or if you write an
Info file from scratch.

* Menu:

* Using Info-validate::         How to run `Info-validate'.
* Unsplit::                     How to create an unsplit file.
* Tagifying::                   How to tagify a file.
* Splitting::                   How to split a file manually.


File: texinfo,  Node: Using Info-validate,  Next: Unsplit,  Prev: Running Info-Validate,  Up: Running Info-Validate

Running `Info-validate'
-----------------------

   To use `Info-validate', visit the Info file you wish to check and
type:

     M-x Info-validate

(Note that the `Info-validate' command requires an upper case `I'. 
You may also need to create a tag table before running
`Info-validate'.  *Note Tagifying::.)

   If your file is valid, you will receive a message that says "File
appears valid".  However, if you have a pointer that does not point to
a node, error messages will be displayed in a buffer called `*problems
in info file*'.

   For example, `Info-validate' was run on a test file that contained
only the first node of this manual.  One of the messages said:

     In node "Overview", invalid Next: Texinfo Mode

This meant that the node called `Overview' had a `Next' pointer that
did not point to anything (which was true in this case, since the test
file had only one node in it).

   Now suppose we add a node named `Texinfo Mode' to our test case but
we don't specify a `Previous' for this node.  Then we will get the
following error message:

     In node "Texinfo Mode", should have Previous: Overview

This is because every `Next' pointer should be matched by a `Previous'
(in the node where the `Next' points) which points back.

   `Info-validate' also checks that all menu items and cross references
point to actual nodes.

   Note that `Info-validate' requires a tag table and does not work
with files that have been split.  (The `texinfo-format-buffer' command
automatically splits files larger than 100,000 bytes.)  In order to
use `Info-validate' on a large file, you must run
`texinfo-format-buffer' with an argument so that it does not split the
Info file; and you must create a tag table for the unsplit file.


File: texinfo,  Node: Unsplit,  Next: Tagifying,  Prev: Using Info-validate,  Up: Running Info-Validate

Creating an Unsplit File
------------------------

   You can run `Info-validate' only on a single Info file that has a
tag table.  The command will not work on the indirect subfiles that
are generated when a master file is split.  If you have a large file
(longer than 70,000 bytes or so), you need to run the
`texinfo-format-buffer' or `makeinfo-buffer' command in such a way
that it does not create indirect subfiles.  You will also need to
create a tag table for the Info file.  After you have done this, you
can run `Info-validate' and look for badly referenced nodes.

   The first step is to create an unsplit Info file.  To prevent
`texinfo-format-buffer' from splitting a Texinfo file into smaller
Info files, give a prefix to the `M-x texinfo-format-buffer' command:

     C-u  M-x texinfo-format-buffer

or else

     C-u C-c C-e C-b

When you do this, Texinfo will not split the file and will not create
a tag table for it.


File: texinfo,  Node: Tagifying,  Next: Splitting,  Prev: Unsplit,  Up: Running Info-Validate

Tagifying a File
----------------

   After creating an unsplit Info file, you must create a tag table for
it.  Visit the Info file you wish to tagify and type:

     M-x Info-tagify

(Note the upper case I in `Info-tagify'.)  This creates an Info file
with a tag table that you can validate.

   The third step is to validate the Info file:

     M-x Info-validate

(Note the upper case I in `Info-validate'.) In brief, the steps are:

     C-u M-x texinfo-format-buffer
     M-x Info-tagify
     M-x Info-validate

   After you have validated the node structure, you can rerun
`texinfo-format-buffer' in the normal way so it will construct a tag
table and split the file automatically, or you can make the tag table
and split the file manually.


File: texinfo,  Node: Splitting,  Prev: Tagifying,  Up: Running Info-Validate

Splitting a File Manually
-------------------------

   You should split a large file or else let the
`texinfo-format-buffer' or `makeinfo-buffer' command do it for you
automatically.  (Generally you will let one of the formatting commands
do this job for you.  *Note Creating an Info File::.)

   The split off files are called the indirect subfiles.

   Info files are split to save memory.  With smaller files, Emacs
does not have make such a large buffer to hold the information.

   If an Info file has more than 30 nodes, you should also make a tag
table for it. *Note Using Info-validate::, for information about
creating a tag table.  (Again, tag tables are usually created
automatically by the formatting command; you only need to create a tag
table yourself if you are doing the job manually.  Most likely, you
will do this for a large, unsplit file on which you have run
`Info-validate'.)

   Visit the file you wish to tagify and split and type the two
commands:

     M-x Info-tagify
     M-x Info-split

(Note that the `I' in `Info' is upper case.)

   When you use the `Info-split' command, the buffer is modified into a
(small) Info file which lists the indirect subfiles.  This file should
be saved in place of the original visited file.  The indirect subfiles
are written in the same directory the original file is in, with names
generated by appending `-' and a number to the original file name.

   The primary file still functions as an Info file, but it contains
just the tag table and a directory of subfiles.


File: texinfo,  Node: Refilling Paragraphs,  Next: Command Syntax,  Prev: Catching Mistakes,  Up: Top

Refilling Paragraphs
********************

   The `@refill' command refills and, optionally, indents the first
line of a paragraph.(1)

   If a paragraph contains long @-constructs, the paragraph may look
badly filled after being formatted by `texinfo-format-region' or
`texinfo-format-buffer'.  this is because both `texinfo-format-region'
and `texinfo-format-buffer' remove @-commands from formatted text but
do not refill paragraphs automatically although both TeX and
`makeinfo' do.  Consequently, some lines become shorter than they were.

   To cause the `texinfo-format-region' and `texinfo-format-buffer'
commands to refill a paragraph, write `@refill' at the end of the
paragraph.  This command refills a paragraph in the Info file after
all the other processing has been done.  `@refill' has no effect on
TeX or `makeinfo', which always fill every paragraph that ought to be
filled.

   For example, without any indenting, the following

     To use @code{foo}, pass @samp{xx%$} and
     @var{flag} and type @kbd{x} after running
     @code{make-foo}.@refill

produces (in the Info file)

     To use `foo', pass `xx%$' and FLAG and type `x' after
     running `make-foo'.

whereas without the `@refill' it would produce

     To use `foo', pass `xx%$' and
     FLAG and type `x' after running
     `make-foo'.

with the line broken at the same place as in the Texinfo input file.

   Write the `@refill' command at the end of the paragraph.  Do not
put a space before `@refill'; otherwise the command might be put at
the beginning of the line when you refill the paragraph in the Texinfo
file with `M-q' (`fill-paragraph').  If this were to happen, the
`@refill' command might fail to work.

   Do not put braces after `@refill'.  The `@refill' command is the
only `within-paragraph' @-command that does not take braces.  Because
an `@refill' command is placed at the end of a paragraph and never at
the beginning of a line, the braces are not necessary.

   As an exception to the general rule, you can write an `@refill'
command at the end of a footnote before the footnote's closing brace,
even if the footnote text is embedded in a the middle of a paragraph
in the Texinfo file.  This is because the footnote text is extracted
from the surrounding text and formatted on its own.

   Also, do not end a paragraph that uses either `@*' or `@w' with an
`@refill' command; otherwise, `texinfo-format-buffer' or
`texinfo-format-buffer' will refill the paragraph in spite of those
commands.

   In addition to refilling, the `@refill' command may insert spaces
at the beginning of the first line of the paragraph, thereby indenting
that line.  The argument to the `@paragraphindent' command specifies
the amount of indentation: if the value of the argument is 0, an
`@refill' command deletes existing indentation.  If the value of the
argument is greater than 0, an `@refill' command indents the paragraph
by that number of spaces.  And if the value of the argument is `asis',
an `@refill' command does not change existing indentation.  For more
information about the `@paragraphindent' command, *Note Paragraph
Indenting: paragraphindent.

   The `@refill' command does not indent entries in a list, table, or
definition, nor does `@refill' indent paragraphs preceded by
`@noindent'.

   ---------- Footnotes ----------

   (1)  Perhaps the command should have been called the
`@refillandindent' command, but `@refill' is shorter and the name was
chosen before indenting was possible.


File: texinfo,  Node: Command Syntax,  Next: New Features,  Prev: Refilling Paragraphs,  Up: Top

@-Command Syntax
****************

   The character `@' is used to start special Texinfo commands.  (It
has the same meaning that `\' has in plain TeX.)  Texinfo has four
types of @-command:

1. Non-alphabetic commands.
     These commands consist of an @ followed by a punctuation mark or
     other character that is not part of the alphabet.  Non-alphabetic
     commands are almost always part of the text within a paragraph,
     and never take any argument.  The two characters (@ and the other
     one) are complete in themselves; none is followed by braces.  The
     non-alphabetic commands are: `@.', `@:', `@*', `@@', `@{', and
     `@}'.

2. Alphabetic commands that do not require arguments.
     These commands start with @ followed by a word followed by left-
     and right-hand braces.  These commands insert special symbols in
     the document; they do not require arguments.  For example,
     `@dots{}' => `...', `@equiv{}' => `==', `@TeX{}' => `TeX', and
     `@bullet{}' => `*'.

3. Alphabetic commands that do require arguments.
     These commands start with @ followed by a letter or a word,
     followed by an argument within braces.  For example, the command
     `@dfn' indicates the introductory or defining use of a term; it
     is used as follows: `In Texinfo, @@-commands are @dfn{mark-up}
     commands.'

4. Alphabetic commands that occupy an entire line.
     These commands occupy an entire line.  The line starts with @,
     followed by the name of the command (a word) such as `@center' or
     `@cindex'.  If no argument is needed, the word is followed by the
     end of the line.  If there is an argument, it is separated from
     the command name by a space.  Braces are not used.

   Thus, the alphabetic commands fall into three classes that have
different argument syntax.  You cannot tell to which class a command
belongs by the appearance of its name, but you can tell by the
command's meaning: if the command stands for a special glyph, it is in
class 2 and does not require an argument; if it makes sense to use the
command together with other text as part of a paragraph, the command
is in class 3 and must be followed by an argument in braces;
otherwise, it is in class 4 and uses the rest of the line as its
argument.

   The purpose of having a different syntax for commands of classes 3
and 4 is to make Texinfo files easier to read, and also to help the GNU
Emacs paragraph and filling commands work properly.  There is only one
exception to this rule: the command `@refill', which is always used at
the end of a paragraph immediately following the final period or other
punctuation character.  `@refill' takes no argument and does *not*
require braces.  `@refill' never confuses the Emacs paragraph commands
because it cannot appear at the beginning of a line.


File: texinfo,  Node: New Features,  Next: Command and Variable Index,  Prev: Command Syntax,  Up: Top

Second Edition Features
***********************

   The second edition of the Texinfo manual describes more than 20 new
Texinfo mode commands and more than 50 previously undocumented Texinfo
@-commands.  This edition is more than twice the length of the first
edition.

   Here is a brief description of the new commands.

* Menu:

* New Texinfo Mode Commands::   The updating commands are especially useful.
* New Commands::                Many newly described @-commands.


File: texinfo,  Node: New Texinfo Mode Commands,  Next: New Commands,  Prev: New Features,  Up: New Features

New Texinfo Mode Commands
=========================

   Texinfo mode provides commands and features especially designed for
working with Texinfo files.  More than 20 new commands have been
added, including commands for automatically creating and updating
nodes and menus, a tedious task when done by hand.

   The keybindings are intended to be somewhat mnemonic.

Update Pointers
---------------

   Create or update `Next', `Previous', and `Up' node pointers.

*Note Updating Nodes and Menus::.

     C-c C-u C-n     Update a node.
     C-c C-u C-e     Update every node in the buffer.

Update Menus
------------

   Create or update menus.

*Note Updating Nodes and Menus::.

     C-c C-u m       Create or update a master menu.
                     With an argument, first create or
                     update all nodes and regular menus.
     
     C-c C-u C-m     Make or update a menu.
     
     C-c C-u C-a     Make or update all the menus
                     in a buffer; with an argument,
                     first update all the nodes.

Format for Info
---------------

   Provide keybindings both for the Info formatting commands that are
written in Emacs Lisp and for `makeinfo' which is written in C.

*Note Info Formatting::.

Use the Emacs lisp `texinfo-format...' commands:

     C-c C-e C-r     Format the region.
     C-c C-e C-b     Format the buffer.

Use `makeinfo':

     C-c C-m C-r     Format the region.
     C-c C-m C-b     Format the buffer.
     C-c C-m C-l     Recenter the `makeinfo' output buffer.
     C-c C-m C-k     Kill the `makeinfo' formatting job.

Typeset and Print
-----------------

   Typeset and print Texinfo documents from within Emacs.

*Note Printing::.

     C-c C-t C-r     Run TeX on the region.
     C-c C-t C-b     Run TeX on the buffer.
     C-c C-t C-i     Run `texindex'.
     C-c C-t C-p     Print the DVI file.
     C-c C-t C-q     Show the print queue.
     C-c C-t C-d     Delete a job from the print queue.
     C-c C-t C-k     Kill the current TeX formatting job.
     C-c C-t C-x     Quit a currently stopped TeX formatting job.
     C-c C-t C-l     Recenter the output buffer.

Other Updating Commands
-----------------------

   The "other updating commands" do not have standard keybindings
because they are less frequently used.

*Note Other Updating Commands::.

     M-x texinfo-insert-node-lines
                     Insert missing node lines using
                     section titles as node names.
     
     M-x texinfo-multiple-files-update
                     Update a multi-file document.
     
     M-x texinfo-indent-menu-description
                     Indent descriptions in menus.
     
     M-x texinfo-sequential-node-update
                     Insert node pointers in strict sequence.


File: texinfo,  Node: New Commands,  Prev: New Texinfo Mode Commands,  Up: New Features

New Texinfo @-Commands
======================

   The second edition of the Texinfo manual describes more than 50
commands that were not described in the first edition.  A third or so
of these commands existed in Texinfo but were not documented in the
manual; the others are new.  Here is a listing, with brief
descriptions of them:

Indexing
--------

Commands for creating your own index and for merging two indices:

*Note Indices::.

     @defindex INDEX-NAME
                  Define a new index and its indexing command.
                  See also the `@defcodeindex' command.
     
     @synindex FROM-INDEX INTO-INDEX
                  Merge first index into second index.
                  See also the `@syncodeindex' command.

Definitions
-----------

Many commands to help you describe functions, variables, macros,
commands, user options, special forms and other such artifacts in a
uniform format.

*Note Definition Commands::.

     @deffn CATEGORY NAME ARGUMENTS...
                  Format a description for functions, interactive
                  commands, and similar entities.
     
     @defvr, @defop, ...
                  15 other related commands.

Glyphs
------

Special symbols to indicate the results of evaluation or an expansion,
printed output, an error message, equivalence of expressions, and the
location of point.

*Note Special Glyphs::.

     @equiv{}     Equivalence:`=='
     
     @error{}     Error message: `error-->'
     
     @expansion{} Macro expansion: `==>'
     
     @point{}     Position of point: `-!-'
     
     @print{}     Printed output: `-|'
     
     @result{}    Result of an expression: `=>'

Headings
--------

Commands to customize headings.

*Note Headings::.

     @headings ON-OFF-SINGLE-DOUBLE
                  Headings on or off, single or double-sided.
     
     @evenfooting [LEFT] @| [CENTER] @| [RIGHT]
                  Footings for even-numbered (left-hand) pages.
     
     @evenheading, @everyheading, @oddheading, ...
                  Five other related commands.
     
     @thischapter
                  Insert name of chapter and chapter number.
     
     @thischaptername, @thisfile, @thistitle, @thispage
                  Related commands.

Formatting
----------

Commands for formatting text:

*Note Quotations and Examples::, and
 *Note Making Lists and Tables: Lists and Tables.

     @cartouche   Draw rounded box surrounding text (not in Info).
     
     @enumerate OPTIONAL-ARG
                  Enumerate a list with letters or numbers.
     
     @exdent LINE-OF-TEXT
                  Remove indentation.
     
     @flushleft       Left justify.
     
     @flushright      Right justify.
     
     @format      Do not narrow nor change font.
     
     @ftable FORMATTING-COMMAND
                  Two column table with indexing.
     
     @lisp        For an example of Lisp code.
     
     @smallexample
                  Like @example but for @smallbook.

Conditionally formatting text:

*Note `@set' and `@clear': set and clear.

     @set FLAG    Set a flag.
     
     @clear FLAG  Clear a flag.
     
     @ifset FLAG  Format, if flag is set.
     
     @ifclear FLAG
                  Ignore, if flag is set.

@heading series for Titles
--------------------------

Produce unnumbered headings that do not appear in a table of contents.

*Note Structuring::.

     @heading TITLE
                  Unnumbered section-like heading not listed
                  table of contents of a printed manual.
     
     @chapheading, @majorheading
     @subheading, @subsubheading
                  Related commands.

Fonts
-----

Font commands.

*Note Smallcaps::, and 
 *Note Fonts::.

     @r{TEXT}     Print in roman font.
     
     
     @sc{TEXT}    Print in SMALL CAPS font.

Miscellaneous
-------------

This list includes a useful cross reference command among others.

See *Note `@title' `@subtitle' and `@author' Commands: title subtitle
author, 
 see *Note Cross Reference Commands::, 
 see *Note Format a Dimension: dmn, 
 see *Note Inserting a Minus Sign: minus, 
 see *Note Footnotes::, 
 see *Note Overfull Hboxes::, and 
 see *Note Refilling Paragraphs::.

     @author AUTHOR
                  Typeset author's names.
     
     @finalout    Produce cleaner printed output.
     
     @footnotestyle
                  Specify footnote style.
     
     @dmn{DIMENSION}
                  Format a dimension.
     
     @minus{}     Generate a minus sign.
     
     @paragraphindent
                  Specify paragraph indentation.
     
     @ref{NODE-NAME, [ENTRY], [TOPIC], [INFO-FILE], [MANUAL]}
                  Make a reference.  In the printed manual, the
                  reference does not start with a `See'.
     
     @title TITLE
                  Title in the alternative title page format.
     
     @subtitle SUBTITLE
                  Subtitle in the alternative title page format.
     
     @today{}     Insert the current date.

