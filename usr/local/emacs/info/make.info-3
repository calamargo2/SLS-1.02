Info file make.info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

   This file documents the GNU Make utility.

   Copyright (C) 1988-1991 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: make.info,  Node: Variables/Recursion,  Next: Options/Recursion,  Prev: MAKE Variable,  Up: Recursion

Communicating Variables to a Sub-`make'
---------------------------------------

   Most variable values of the top-level `make' are passed to the
sub-`make' through the environment.  These variables are defined in
the sub-`make' as defaults, but do not override what is specified in
the sub-`make''s makefile.

   Variables are passed down if their names consist only of letters,
numbers and underscores.  Some shells cannot cope with environment
variable names consisting of characters other than letters, numbers,
and underscores.

   Variable are *not* passed down if they were created by default by
`make' (*note Implicit Variables::.).  The sub-`make' will define
these for itself.

   The way this works is that `make' adds each variable and its value
to the environment for running each command.  The sub-`make', in turn,
uses the environment to initialize its table of variable values. 
*Note Environment::.

   As a special feature, the variable `MAKELEVEL' is changed when it is
passed down from level to level.  This variable's value is a string
which is the depth of the level as a decimal number.  The value is `0'
for the top-level `make'; `1' for a sub-`make', `2' for a
sub-sub-`make', and so on.  The incrementation happens when `make'
sets up the environment for a command.

   The main use of `MAKELEVEL' is to test it in a conditional directive
(*note Conditionals::.); this way you can write a makefile that
behaves one way if run recursively and another way if run directly by
you.

   You can use the variable `MAKEFILES' to cause all sub-`make'
commands to use additional makefiles.  The value of `MAKEFILES' is a
whitespace-separated list of filenames.  This variable, if defined in
the outer-level makefile, is passed down through the environment as
usual; then it serves as a list of extra makefiles for the sub-`make'
to read before the usual or specified ones.  *Note MAKEFILES
Variable::.


File: make.info,  Node: Options/Recursion,  Next: -w Option,  Prev: Variables/Recursion,  Up: Recursion

Communicating Options to a Sub-`make'
-------------------------------------

   Flags such as `-s' and `-k' are passed automatically to the
sub-`make' through the variable `MAKEFLAGS'.  This variable is set up
automatically by `make' to contain the flag letters that `make'
received.  Thus, if you do `make -ks' then `MAKEFLAGS' gets the value
`ks'.

   As a consequence, every sub-`make' gets a value for `MAKEFLAGS' in
its environment.  In response, it takes the flags from that value and
processes them as if they had been given as arguments.  *Note
Options::.

   The options `-C', `-f', `-I', `-o', and `-W' are not put into
`MAKEFLAGS'; these options are not passed down.

   The `-j' (*note Parallel::.) option is a special case.  If you set
it to some numeric value, `-j 1' is always put into `MAKEFLAGS'
instead of the value you specified.  This is because if the `-j'
option were passed down to sub-`make's, you would get many more jobs
running in parallel than you asked for.  If you give `-j' with no
numeric argument, meaning to run as many jobs as possible in parallel,
this is passed down, since multiple infinities are no more than one.

   If you don't want to pass the other flags down, you must change the
value of `MAKEFLAGS', like this:

     MAKEFLAGS=
     subsystem:
             cd subdir; $(MAKE)

   or like this:

     subsystem:
             cd subdir; $(MAKE) MAKEFLAGS=

   A similar variable `MFLAGS' exists also, for historical
compatibility.  It has the same value as `MAKEFLAGS' except that a
hyphen is added at the beginning if it is not empty.  `MFLAGS' was
traditionally used explicitly in the recursive `make' command, like
this:

     subsystem:
             cd subdir; $(MAKE) $(MFLAGS)

but now `MAKEFLAGS' makes this usage redundant.

   The `MAKEFLAGS' and `MFLAGS' variables can also be useful if you
want to have certain options, such as `-k' (*note Options::.) set each
time you run `make'.  Just put `MAKEFLAGS=k' or `MFLAGS=-k' in your
environment.  These variables may also be set in makefiles, so a
makefile can specify additional flags that should also be in effect for
that makefile.

   If you do put `MAKEFLAGS' or `MFLAGS' in your environment, you
should be sure not to include any options that will drastically affect
the actions of `make' and undermine the purpose of makefiles and of
`make' itself.  For instance, the `-t', `-n', and `-q' options, if put
in one of these variables, could have disastrous consequences and
would certainly have at least surprising and probably annoying effects.


File: make.info,  Node: -w Option,  Prev: Options/Recursion,  Up: Recursion

The `-w' Option
---------------

   If you use several levels of recursive `make' invocations, the `-w'
option can make the output a lot easier to understand by showing each
directory as `make' starts processing it and as `make' finishes
processing it.  For example, if `make -w' is run in the directory
`/u/gnu/make', `make' will print a line of the form:

     make: Entering directory `/u/gnu/make'.

before doing anything else, and a line of the form:

     make: Leaving directory `/u/gnu/make'.

when processing is completed.


File: make.info,  Node: Sequences,  Next: Empty Commands,  Prev: Recursion,  Up: Commands

Defining Canned Command Sequences
=================================

   When the same sequence of commands is useful in making various
targets, you can define it as a canned sequence with the `define'
directive, and refer to the canned sequence from the rules for those
targets.  The canned sequence is actually a variable, so the name must
not conflict with other variable names.

   Here is an example of defining a canned sequence of commands:

     define run-yacc
     yacc $(firstword $^)
     mv y.tab.c $@
     endef

Here `run-yacc' is the name of the variable being defined; `endef'
marks the end of the definition; the lines in between are the
commands.  The `define' directive does not expand variable references
and function calls in the canned sequence; the `$' characters,
parentheses, variable names, and so on, all become part of the value
of the variable you are defining.  *Note Defining::, for a complete
explanation of `define'.

   The first command in this example runs Yacc on the first dependency
(of whichever rule uses the canned sequence).  The output file from
Yacc is always named `y.tab.c'.  The second command moves the output
to the rule's target file name.

   To use the canned sequence, substitute the variable into the
commands of a rule.  You can substitute it like any other variable
(*note Reference::.).  Because variables defined by `define' are
recursively expanded variables, all the variable references you wrote
inside the `define' are expanded now.  For example:

     foo.c : foo.y
             $(run-yacc)

`foo.y' will substituted for the variable `$^' when it occurs in
`run-yacc''s value, and `foo.c' for `$@'.

   This is a realistic example, but this particular one is not needed
in practice because `make' has an implicit rule to figure out these
commands based on the file names involved.  *Note Implicit::.


File: make.info,  Node: Empty Commands,  Prev: Sequences,  Up: Commands

Defining Empty Commands
=======================

   It is sometimes useful to define commands which do nothing.  This
is done simply by giving a command that consists of nothing but
whitespace.  For example:

     target:;

defines an empty command string for `target'.  You could also use a
line beginning with a tab character to define an empty command string,
but this would be confusing because such a line looks empty.

   You may be wondering why you would want to define a command string
that does nothing.  The only reason this is useful is to prevent a
target from getting implicit commands (from implicit rules or the
`.DEFAULT' special target; *note Implicit::. and *note Last Resort::.).

   You may be inclined to define empty command strings for targets
that are not actual files, but only exist so that their dependencies
can be remade.  However, this is not the best way to do that, because
if the target file actually does exist, its dependencies may not be
remade.  *Note Phony Targets::, for a better way to do this.


File: make.info,  Node: Variables,  Next: Conditionals,  Prev: Commands,  Up: Top

How to Use Variables
********************

   A "variable" is a name defined within `make' to represent a string
of text, called the variable's "value".  These values can be
substituted by explicit request into targets, dependencies, commands
and other parts of the makefile.

   Variables can represent lists of file names, options to pass to
compilers, programs to run, directories to look in for source files,
directories to write output in, or anything else you can imagine.

   A variable name may be any sequence characters not containing `:',
`#', `=', or leading or trailing whitespace.  However, variable names
containing characters other than letters, numbers and underscores
should be avoided, as they may be given special meanings in the
future, and they are not passed through the environment to a
sub-`make' (*note Variables/Recursion::.).

   It is traditional to use upper case letters in variable names, but
we recommend using lower case letters for variable names that serve
internal purposes in the makefile, and reserving upper case for
parameters that control implicit rules or for parameters that the user
should override with command options (*note Overriding::.).

* Menu:

* Reference::   How to use the value of a variable.
* Flavors::     Variables come in two flavors.
* Advanced::    Advanced features for referencing a variable.
* Values::      All the ways variables get their values.
* Setting::     How to set a variable in the makefile.
* Override Directive:: Setting a variable in the makefile
                 even if the user has set it with a command argument.
* Defining::    An alternate way to set a variable to a verbatim string.
* Environment:: Variable values can come from the environment.


File: make.info,  Node: Reference,  Next: Flavors,  Prev: Variables,  Up: Variables

Basics of Variable References
=============================

   To substitute a variable's value, write a dollar sign followed by
the name of the variable in parentheses or braces: either `$(foo)' or
`${foo}' is a valid reference to the variable `foo'.  This special
significance of `$' is why you must write `$$' to have the effect of a
single dollar sign in a file name or command.

   Variable references can be used in any context: targets,
dependencies, commands, most directives, and new variable values. 
Here is a common kind of example, where a variable holds the names of
all the object files in a program:

     objects = program.o foo.o utils.o
     program : $(objects)
             cc -o program $(objects)
     
     $(objects) : defs.h

   Variable references work by strict textual substitution.  Thus, the
rule

     foo = c
     prog.o : prog.c
             $(foo)$(foo) prog.c

could be used to compile a C program `prog.c'.  Since spaces around
the variable value are ignored in variable assignments, the value of
`foo' is precisely `c'.  (Don't actually write your makefiles this
way!)

   A dollar sign followed by a character other than a dollar sign,
open-parenthesis or open-brace treats that single character as the
variable name.  Thus, you could reference the variable `x' with `$x'. 
However, this practice is strongly discouraged, except in the case of
the automatic variables (*note Automatic::.).


File: make.info,  Node: Flavors,  Next: Advanced,  Prev: Reference,  Up: Variables

The Two Flavors of Variables
============================

   There are two ways that a variables in GNU `make' can have a value;
we call them two "flavors" of variables.  The two flavors are
distinguished in how they are defined and in what they do when
expanded.

   The first flavor of variable is a "recursively expanded" variable. 
Variables of this sort are defined by lines using `=' (*note
Setting::.).  The value you specify is installed verbatim; if it
contains references to other variables, these references are expanded
whenever this variable is substituted (in the course of expanding some
other string).  When this happens, it is called "recursive expansion".

   For example,

     foo = $(bar)
     bar = $(ugh)
     ugh = Huh?
     
     all:;echo $(foo)

will echo `Huh?': `$(foo)' expands to `$(bar)' which expands to
`$(ugh)' which finally expands to `Huh?'.

   This flavor of variable is the only sort supported by other
versions of `make'.  It has its advantages and its disadvantages.  An
advantage (most would say) is that:

     CFLAGS = $(include_dirs) -O
     include_dirs = -Ifoo -Ibar

will do what was intended: when `CFLAGS' is expanded in a command, it
will expand to `-Ifoo -Ibar -O'.  A major disadvantage is that you
can't append something on the end of a variable, as in

     CFLAGS = $(CFLAGS) -O

because it will cause an infinite loop in the variable expansion. 
(Actually `make' detects the infinite loop and reports an error.)

   Another disadvantage is that any functions (*note Functions::.)
referenced in the definition will be executed every time the variable
is expanded.  This makes `make' run slower; worse, it causes the
`wildcard' and `shell' functions to give unpredictable results because
you cannot easily control when they are called, or even how many times.

   To avoid all the problems and inconveniences of recursively expanded
variables, there is another flavor: "simply expanded" variables.

   Simply expanded variables are defined by lines using `:=' (*note
Setting::.).  The value of a simply expanded variable is scanned once
and for all, expanding any references to other variables and
functions, when the variable is defined.  The actual value of the
simply expanded variable is the result of expanding the text that you
write.  It does not contain any references to other variables; it
contains their values *as of the time this variable was defined*. 
Therefore,

     x := foo
     y := $(x) bar
     x := later

is equivalent to

     y := foo bar
     x := later

   When a simply expanded variable is referenced, its value is
substituted verbatim.

   Simply expanded variables generally make complicated makefile
programming more predictable because they work like variables in most
programming languages.  They allow you to redefine a variable using
its own value (or its value processed in some way by one of the
expansion functions) and to use the expansion functions much more
efficiently (*note Functions::.).

   You can also use them to introduce controlled leading or trailing
spaces into variable values.  Such spaces are discarded from your
input before substitution of variable references and function calls;
this means you can include leading or trailing spaces in a variable
value by protecting them with variable references, like this:

     nullstring :=
     space := $(nullstring) $(nullstring)

Here the value of the variable `space' is precisely one space.


File: make.info,  Node: Advanced,  Next: Values,  Prev: Flavors,  Up: Variables

Advanced Features for Reference to Variables
============================================

   This section describes some advanced features you can use to
reference variables in more flexible ways.

* Menu:

* Substitution Refs::   Referencing a variable with substitutions on the value.
* Computed Names::      Computing the name of the variable to refer to.


File: make.info,  Node: Substitution Refs,  Next: Computed Names,  Prev: Advanced,  Up: Advanced

Substitution References
-----------------------

   A "substitution reference" substitutes the value of a variable with
alterations that you specify.  It has the form `$(VAR:A=B)' (or
`${VAR:A=B}') and its meaning is to take the value of the variable
VAR, replace every A at the end of a word with B in that value, and
substitute the resulting string.

   When we say "at the end of a word", we mean that A must appear
either followed by whitespace or at the end of the value in order to be
replaced; other occurrences of A in the value are unaltered.  For
example:

     foo := a.o b.o c.o
     bar := $(foo:.o=.c)

sets `bar' to `a.c b.c c.c'.  *Note Setting::.

   A substitution reference is actually an abbreviation for use of the
`patsubst' expansion function (*note Text Functions::.).  We provide
substitution references as well as `patsubst' for compatibility with
other implementations of `make'.

   Another type of substitution reference lets you use the full power
of the `patsubst' function.  It has the same form `$(VAR:A=B)'
described above, except that now A must contain a single `%'
character.  This case is equivalent to `$(patsubst A,B,$(VAR))'. 
*Note Text Functions::, for a description of the `patsubst' function. 
For example:

     foo := a.o b.o c.o
     bar := $(foo:%.o=%.c)

sets `bar' to `a.c b.c c.c'.


File: make.info,  Node: Computed Names,  Prev: Substitution Refs,  Up: Advanced

Computed Variable Names
-----------------------

   Computed variable names are a complicated concept needed only for
sophisticated makefile programming.  For most purposes you need not
consider about them, except to know that making a variable with a
dollar sign in its name might have strange results.  However, if you
are the type that wants to understand everything, or you are actually
interested in what they do, read on.

   Variables may be referenced inside the name of a variable.  This is
called a "computed variable name" or a "nested variable reference". 
For example,

     x = y
     y = z
     a := $($(x))

defines `a' as `z': the `$(x)' inside `$($(x))' expands to `y', so
`$($(x))' expands to `$(y)' which in turn expands to `z'.  Here the
name of the variable to reference is not stated explicitly; it is
computed by expansion of `$(x)'.  The reference `$(x)' here is nested
within the outer variable reference.

   The previous example shows two levels of nesting, but any number of
levels is possible.  For example, here are three levels:

     x = y
     y = z
     z = u
     a := $($($(x)))

Here the innermost `$(x)' expands to `y', so `$($(x))' expands to
`$(y)' which in turn expands to `z'; now we have `$(z)', which becomes
`u'.

   References to recursively-expanded variables within a variable name
are reexpanded in the usual fashion.  For example:

     x = $(y)
     y = z
     z = Hello
     a := $($(x))

defines `a' as `Hello': `$($(x))' becomes `$($(y))' which becomes
`$(z)' which becomes `Hello'.

   Nested variable references can also contain modified references and
function invocations (*note Functions::.), just like any other
reference.  For example, using the `subst' function (*note Text
Functions::.):

     x = variable1
     variable2 := Hello
     y = $(subst 1,2,$(x))
     z = y
     a := $($($(z)))

eventually defines `a' as `Hello'.  It is doubtful that anyone would
ever want to write a nested reference as convoluted as this one, but
it works: `$($($(z)))' expands to `$($(y))' which becomes `$($(subst
1,2,$(x)))'.  This gets the value `variable1' from `x' and changes it
by substitution to `variable2', so that the entire string becomes
`$(variable2)', a simple variable reference whose value is `Hello'.

   A computed variable name need not consist entirely of a single
variable reference.  It can contain several variable references, as
well as some invariant text.  For example,

     a_dirs := dira dirb
     1_dirs := dir1 dir2
     
     a_files := filea fileb
     1_files := file1 file2
     
     ifeq "$(use_a)" "yes"
     a1 := a
     else
     a1 := 1
     endif
     
     ifeq "$(use_dirs)" "yes"
     df := dirs
     else
     df := files
     endif
     
     dirs := $($(a1)_$(df))

will give `dirs' the same value as `a_dirs', `1_dirs', `a_files' or
`1_files' depending on the settings of `use_a' and `use_dirs'.

   Computed variable names can also be used in substitution references:

     a_objects := a.o b.o c.o
     1_objects := 1.o 2.o 3.o
     
     sources := $($(a1)_object:.o=.c)

defines `sources' as either `a.c b.c c.c' or `1.c 2.c 3.c', depending
on the value of `a1'.

   The only restriction on this sort of use of nested variable
references is that they cannot specify part of the name of a function
to be called.  This is because the test for a recognized function name
is done before the expansion of nested references.  For example,

     ifdef do_sort
     func := sort
     else
     func := strip
     endif
     
     bar := a d b g q c
     
     foo := $($(func) $(bar))

attempts to give `foo' the value of the variable `sort a d b g q c' or
`strip a d b g q c', rather than giving `a d b g q c' as the argument
to either the `sort' or the `strip' function.  This restriction could
be removed in the future if that change is shown to be a good idea.

   Note that "nested variable references" are quite different from
"recursively expanded variables" (*note Flavors::.), though both are
used together in complex ways when doing makefile programming.


File: make.info,  Node: Values,  Next: Setting,  Prev: Advanced,  Up: Variables

How Variables Get Their Values
==============================

   Variables can get values in several different ways:

   * You can specify an overriding value when you run `make'.  *Note
     Overriding::.

   * You can specify a value in the makefile, either with an
     assignment (*note Setting::.) or with a verbatim definition
     (*note Defining::.).

   * Values are inherited from the environment.  *Note Environment::.

   * Several "automatic" variables are given new values for each rule. 
     Each of these has a single conventional use.  *Note Automatic::.

   * Several variables have constant initial values.  *Note Implicit
     Variables::.


File: make.info,  Node: Setting,  Next: Override Directive,  Prev: Values,  Up: Variables

Setting Variables
=================

   To set a variable from the makefile, write a line starting with the
variable name followed by `=' or `:='.  Whatever follows the `=' or
`:=' on the line becomes the value.  For example,

     objects = main.o foo.o bar.o utils.o

defines a variable named `objects'.  Whitespace around the variable
name and immediately after the `=' is ignored.

   Variables defined with `=' are "recursively expanded" variables. 
Variables defined with `:=' are "simply expanded" variables; these
definitions can contain variable references which will be expanded
before the definition is made.  *Note Flavors::.

   There is no limit on the length of the value of a variable except
the amount of swapping space on the computer.  When a variable
definition is long, it is a good idea to break it into several lines
by inserting backslash-newline at convenient places in the definition.
 This will not affect the functioning of `make', but it will make the
makefile easier to read.

   Most variable names are considered to have the empty string as a
value if you have never set them.  Several variables have built-in
initial values that are not empty, but can be set by you in the usual
ways (*note Implicit Variables::.).  Several special variables are set
automatically to a new value for each rule; these are called the
"automatic" variables (*note Automatic::.).


File: make.info,  Node: Override Directive,  Next: Defining,  Prev: Setting,  Up: Variables

The `override' Directive
========================

   If a variable has been set with a command argument (*note
Overriding::.), then ordinary assignments in the makefile are ignored.
 If you want to set the variable in the makefile even though it was
set with a command argument, you can use an `override' directive,
which is a line that looks like this:

     override VARIABLE = VALUE

   or

     override VARIABLE := VALUE

   The `override' directive was not invented for escalation in the war
between makefiles and command arguments.  It was invented so you can
alter and add to values that the user specifies with command arguments.

   For example, suppose you always want the `-g' switch when you run
the C compiler, but you would like to allow the user to specify the
other switches with a command argument just as usual.  You could use
this `override' directive:

     override CFLAGS := $(CFLAGS) -g

   You can also use `override' directives with `define' directives. 
This is done as you might expect:

     override define foo
     bar
     endef

*Note Defining::.


File: make.info,  Node: Defining,  Next: Environment,  Prev: Override Directive,  Up: Variables

Defining Variables Verbatim
===========================

Another way to set the value of a variable is to use the `define'
directive.  This directive has a different syntax which allows newline
characters to be included in the value, which is convenient for
defining canned sequences of commands (*note Sequences::.).

   The `define' directive is followed on the same line by the name of
the variable and nothing more.  The value to give the variable appears
on the following lines.  The end of the value is marked by a line
containing just the word `endef'.  Aside from this difference in
syntax, `define' works just like `='; it creates a
recursively-expanded variable (*note Flavors::.).

     define two-lines
     echo foo
     echo $(bar)
     endef

   The value in an ordinary assignment cannot contain a newline; but
the newlines that separate the lines of the value in a `define' become
part of the variable's value (except for the final newline which
precedes the `endef' and is not considered part of the value).

   The previous example is functionally equivalent to this:

     two-lines = echo foo; echo $(bar)

since the shell will interpret the semicolon and the newline
identically.

   If you want variable definitions made with `define' to take
precedence over command-line variable definitions, the `override'
directive can be used together with `define':

     override define two-lines
     foo
     $(bar)
     endef

*Note Override Directive::.


File: make.info,  Node: Environment,  Prev: Defining,  Up: Variables

Variables from the Environment
==============================

   Variables in `make' can come from the environment with which `make'
is run.  Every environment variable that `make' sees when it starts up
is transformed into a `make' variable with the same name and value. 
But an explicit assignment in the makefile, or with a command
argument, overrides the environment.  (If the `-e' flag is specified,
then values from the environment override assignments in the makefile. 
*Note Options::.  But this is not recommended practice.)

   Thus, by setting the variable `CFLAGS' in your environment, you can
cause all C compilations in most makefiles to use the compiler
switches you prefer.  This is safe for variables with standard or
conventional meanings because you know that no makefile will use them
for other things.  (But this is not totally reliable; some makefiles
set `CFLAGS' explicitly and therefore are not affected by the value in
the environment.)

   When `make' is invoked recursively, variables defined in the outer
invocation are automatically passed to inner invocations through the
environment (*note Recursion::.).  This is the main purpose of turning
environment variables into `make' variables, and it requires no
attention from you.

   Other use of variables from the environment is not recommended.  It
is not wise for makefiles to depend for their functioning on
environment variables set up outside their control, since this would
cause different users to get different results from the same makefile.
 This is against the whole purpose of most makefiles.

   Such problems would be especially likely with the variable `SHELL',
which is normally present in the environment to specify the user's
choice of interactive shell.  It would be very undesirable for this
choice to affect `make'.  So `make' ignores the environment value of
`SHELL' if the value of `MAKELEVEL' is zero (which is normally true
except in recursive invocations of `make').


File: make.info,  Node: Conditionals,  Next: Functions,  Prev: Variables,  Up: Top

Conditional Parts of Makefiles
******************************

   A "conditional" causes part of a makefile to be obeyed or ignored
depending on the values of variables.  Conditionals can compare the
value of one variable with another, or the value of a variable with a
constant string.  Conditionals control what `make' actually "sees" in
the makefile, so they *cannot* be used to control shell commands at the
time of execution.

* Menu:

* Example: Conditional Example.   An annotated example.
* Syntax: Conditional Syntax.     Precise rules for syntax of conditionals.
* Flags: Testing Flags.           Conditionals testing flags such as `-t'.


File: make.info,  Node: Conditional Example,  Next: Conditional Syntax,  Prev: Conditionals,  Up: Conditionals

Example of a Conditional
========================

   This conditional tells `make' to use one set of libraries if the
`CC' variable is `gcc', and a different set of libraries otherwise. 
It works by controlling which of two command lines will be used as the
command for a rule.  The result is that `CC=gcc' as an argument to
`make' changes not only which compiler is used but also which
libraries are linked.

     libs_for_gcc = -lgnu
     normal_libs =
     
     foo: $(objects)
     ifeq ($(CC),gcc)
             $(CC) -o foo $(objects) $(libs_for_gcc)
     else
             $(CC) -o foo $(objects) $(normal_libs)
     endif

   This conditional uses three directives: one `ifeq', one `else' and
one `endif'.

   The `ifeq' directive begins the conditional, and specifies the
condition.  It contains two arguments, separated by a comma and
surrounded by parentheses.  Variable substitution is performed on both
arguments and then they are compared.  The lines of the makefile
following the `ifeq' are obeyed if the two arguments match; otherwise
they are ignored.

   The `else' directive causes the following lines to be obeyed if the
previous conditional failed.  In the example above, this means that the
second alternative linking command is used whenever the first
alternative is not used.  It is optional to have an `else' in a
conditional.

   The `endif' directive ends the conditional.  Every conditional must
end with an `endif'.  Unconditional makefile text follows.

   Conditionals work at the textual level: the lines of the
conditional are treated as part of the makefile, or ignored, according
to the condition.  This is why the larger syntactic units of the
makefile, such as rules, may cross the beginning or the end of the
conditional.

   When the variable `CC' has the value `gcc', the above example has
this effect:

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs_for_gcc)

When the variable `CC' has any other value, the effect is this:

     foo: $(objects)
             $(CC) -o foo $(objects) $(normal_libs)

   Equivalent results can be obtained in another way by
conditionalizing a variable assignment and then using the variable
unconditionally:

     libs_for_gcc = -lgnu
     normal_libs =
     
     ifeq ($(CC),gcc)
       libs=$(libs_for_gcc)
     else
       libs=$(normal_libs)
     endif
     
     foo: $(objects)
             $(CC) -o foo $(objects) $(libs)


File: make.info,  Node: Conditional Syntax,  Next: Testing Flags,  Prev: Conditional Example,  Up: Conditionals

Syntax of Conditionals
======================

   The syntax of a simple conditional with no `else' is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     endif

The TEXT-IF-TRUE may be any lines of text, to be considered as part of
the makefile if the condition is true.  If the condition is false, no
text is used instead.

   The syntax of a complex conditional is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     else
     TEXT-IF-FALSE
     endif

If the condition is true, TEXT-IF-TRUE is used; otherwise,
TEXT-IF-FALSE is used instead.  The TEXT-IF-FALSE can be any number of
lines of text.

   The syntax of the CONDITIONAL-DIRECTIVE is the same whether the
conditional is simple or complex.  There are four different directives
that test different conditions.  Here is a table of them:

`ifeq (ARG1, ARG2)'
`ifeq 'ARG1' 'ARG2''
`ifeq "ARG1" "ARG2"'
`ifeq "ARG1" 'ARG2''
`ifeq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare them.
      If they are identical, the TEXT-IF-TRUE is effective; otherwise,
     the TEXT-IF-FALSE, if any, is effective.

`ifneq (ARG1, ARG2)'
`ifneq 'ARG1' 'ARG2''
`ifneq "ARG1" "ARG2"'
`ifneq "ARG1" 'ARG2''
`ifneq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare them.
      If they are different, the TEXT-IF-TRUE is effective; otherwise,
     the TEXT-IF-FALSE, if any, is effective.

`ifdef VARIABLE-NAME'
     If the variable VARIABLE-NAME has a non-empty value, the
     TEXT-IF-TRUE is effective; otherwise, the TEXT-IF-FALSE, if any,
     is effective.  Variables that have never been defined have an
     empty value.

`ifndef VARIABLE-NAME'
     If the variable VARIABLE-NAME has an empty value, the
     TEXT-IF-TRUE is effective; otherwise, the TEXT-IF-FALSE, if any,
     is effective.

   Extra spaces are allowed and ignored at the beginning of the
conditional directive line, but a tab is not allowed.  (If the line
begins with a tab, it will be considered a command for a rule.)  Aside
from this, extra spaces or tabs may be inserted with no effect
anywhere except within the directive name or within an argument.  A
comment starting with `#' may appear at the end of the line.

   The other two directives that play a part in a conditional are
`else' and `endif'.  Each of these directives is written as one word,
with no arguments.  Extra spaces are allowed and ignored at the
beginning of the line, and spaces or tabs at the end.  A comment
starting with `#' may appear at the end of the line.

   Conditionals work at the textual level.  The lines of the
TEXT-IF-TRUE are read as part of the makefile if the condition is
true; if the condition is false, those lines are ignored completely. 
It follows that syntactic units of the makefile, such as rules, may
safely be split across the beginning or the end of the conditional.

   To prevent intolerable confusion, it is not permitted to start a
conditional in one makefile and end it in another.  However, you may
write an `include' directive within a conditional, provided you do not
attempt to terminate the conditional inside the included file.


File: make.info,  Node: Testing Flags,  Prev: Conditional Syntax,  Up: Conditionals

Conditionals that Test Flags
============================

   You can write a conditional that tests `make' command flags such as
`-t' by using the variable `MAKEFLAGS' together with the `findstring'
function.  This is useful when `touch' is not enough to make a file
appear up to date.

   The `findstring' function determines whether one string appears as a
substring of another.  If you want to test for the `-t' flag, use `t'
as the first string and the value of `MAKEFLAGS' as the other.

   For example, here is how to arrange to use `ranlib -t' to finish
marking an archive file up to date:

     archive.a: ...
     ifneq (,$(findstring t,$(MAKEFLAGS)))
             @echo $(MAKE) > /dev/null
             touch archive.a
             ranlib -t archive.a
     else
             ranlib archive.a
     endif

The `echo' command does nothing when executed; but its presence, with
a reference to the variable `MAKE', marks the rule as "recursive" so
that its commands will be executed despite use of the `-t' flag. 
*Note Recursion::.


File: make.info,  Node: Functions,  Next: Running,  Prev: Conditionals,  Up: Top

Functions for Transforming Text
*******************************

   "Functions" allow you to do text processing in the makefile to
compute the files to operate on or the commands to use.  You use a
function in a "function call", where you give the name of the function
and some text (the "arguments") for the function to operate on.  The
result of the function's processing is substituted into the makefile
at the point of the call, just as a variable might be substituted.

* Menu:

* Syntax of Functions:: How to write a function call.
* Text Functions::      General-purpose text manipulation functions.
* Filename Functions::  Functions for manipulating file names.
* Foreach Function::    Repeat some text with controlled variation.
* Origin Function::     Find where a variable got its value.
* Shell Function::      Substitute the output of a shell command.


File: make.info,  Node: Syntax of Functions,  Next: Text Functions,  Prev: Functions,  Up: Functions

Function Call Syntax
====================

   A function call resembles a variable reference.  It looks like this:

     $(FUNCTION ARGUMENTS)

or like this:

     ${FUNCTION ARGUMENTS}

   Here FUNCTION is a function name; one of a short list of names that
are part of `make'.  There is no provision for defining new functions.

   The ARGUMENTS are the arguments of the function.  They are separated
from the function name by one or more spaces and/or tabs, and if there
is more than one argument they are separated by commas.  Such
whitespace and commas are not part of any argument's value.  The
delimiters which you use to surround the function call, whether
parentheses or braces, can appear in an argument only in matching
pairs; the other kind of delimiters may appear singly.  If the
arguments themselves contain other function calls or variable
references, it is wisest to use the same kind of delimiters for all
the references; in other words, write `$(subst a,b,$(x))', not
`$(subst a,b,${x})'.  This is both because it is clearer, and because
only one type of delimiters is matched to find the end of the
reference.  Thus in `$(subst a,b,${subst c,d,${x}})' doesn't work
because the second `subst' function invocation ends at the first `}',
not the second.

   The text written for each argument is processed by substitution of
variables and function calls to produce the argument value, which is
the text on which the function acts.  The substitution is done in the
order in which the arguments appear.

   Commas and unmatched parentheses or braces cannot appear in the
text of an argument as written; leading spaces cannot appear in the
text of the first argument as written.  These characters can be put
into the argument value by variable substitution.  First define
variables `comma' and `space' whose values are isolated comma and
space characters, then substitute those variables where such
characters are wanted, like this:

     comma:= ,
     space:= $(empty) $(empty)
     foo:= a b c
     bar:= $(subst $(space),$(comma),$(foo))
     # bar is now `a,b,c'.

Here the `subst' function replaces each space with a comma, through
the value of `foo', and substitutes the result.


File: make.info,  Node: Text Functions,  Next: Filename Functions,  Prev: Syntax of Functions,  Up: Functions

Functions for String Substitution and Analysis
==============================================

   Here are some functions that operate on strings:

`$(subst FROM,TO,TEXT)'
     Performs a textual replacement on the text TEXT: each occurrence
     of FROM is replaced by TO.  The result is substituted for the
     function call.  For example,

          $(subst ee,EE,feet on the street)

          substitutes the string `fEEt on the strEEt'.

`$(patsubst PATTERN,REPLACEMENT,TEXT)'
     Finds whitespace-separated words in TEXT that match PATTERN and
     replaces them with REPLACEMENT.  Here PATTERN may contain a `%'
     which acts as a wildcard, matching any number of any characters
     within a word.  If REPLACEMENT also contains a `%', the `%' is
     replaced by the text that matched the `%' in PATTERN.

     `%' characters in `patsubst' function invocations can be quoted
     with preceding backslashes (`\').  Backslashes that would
     otherwise quote `%' characters can be quoted with more
     backslashes.  Backslashes that quote `%' characters or other
     backslashes are removed from the pattern before it is compared
     file names or has a stem substituted into it.  Backslashes that
     are not in danger of quoting `%' characters go unmolested.  For
     example, the pattern `the\%weird\\%pattern\\' has `the%weird\'
     preceding the operative `%' character, and `pattern\\' following
     it.  The final two backslashes are left alone because they can't
     affect any `%' character.

     Whitespace between words is folded into single space characters;
     leading and trailing whitespace is discarded.

     For example,

          $(patsubst %.c,%.o,x.c.c bar.c)

          produces the value `x.c.o bar.o'.

`$(strip STRING)'
     Removes leading and trailing whitespace from STRING and replaces
     each internal sequence of one or more whitespace characters with a
     single space.  Thus, `$(strip a b  c )' results in `a b c'.

`$(findstring FIND,IN)'
     Searches IN for an occurrence of FIND.  If it occurs, the value
     is FIND; otherwise, the value is empty.  You can use this
     function in a conditional to test for the presence of a specific
     substring in a given string.  Thus, the two examples,

          $(findstring a,a b c)
          $(findstring a,b c)

          produce the values `a' and `', respectively.  *Note Testing
     Flags::, for a practical application of `findstring'.

`$(filter PATTERN,TEXT)'
     Removes all whitespace-separated words in TEXT that do *not*
     match PATTERN, returning only matching words.  The pattern is
     written using `%', just like the patterns used in `patsubst'
     function above.

     The `filter' function can be used to separate out different types
     of strings (such as filenames) in a variable.  For example:

          sources := foo.c bar.c ugh.h
          foo: $(sources)
                  cc $(filter %.c,$(sources)) -o foo

          says that `foo' depends of `foo.c', `bar.c' and `ugh.h' but only
     `foo.c' and `bar.c' should be specified in the command to the
     compiler.

`$(filter-out PATTERN,TEXT)'
     Removes all whitespace-separated words in TEXT that *do* match
     PATTERN, returning only the words that match.  This is the exact
     opposite of the `filter' function.

`$(sort LIST)'
     Sorts the words of LIST in lexical order, removing duplicate
     words.  The output is a list of words separated by single spaces. 
     Thus,

          $(sort foo bar lose)

          returns the value `bar foo lose'.

   Here is a realistic example of the use of `subst' and `patsubst'. 
Suppose that a makefile uses the `VPATH' variable to specify a list of
directories that `make' should search for dependency files.  This
example shows how to tell the C compiler to search for header files in
the same list of directories.

   The value of `VPATH' is a list of directories separated by colons,
such as `src:../headers'.  First, the `subst' function is used to
change the colons to spaces:

     $(subst :, ,$(VPATH))

This produces `src ../headers'.  Then `patsubst' is used to turn each
directory name into a `-I' flag.  These can be added to the value of
the variable `CFLAGS', which is passed automatically to the C
compiler, like this:

     override CFLAGS:= $(CFLAGS) $(patsubst %,-I%,$(subst :, ,$(VPATH)))

The effect is to append the text `-Isrc -I../headers' to the
previously given value of `CFLAGS'.  The `override' directive is used
so that the new value is assigned even if the previous value of
`CFLAGS' was specified with a command argument (*note Override
Directive::.).

   The function `strip' can be very useful when used in conjunction
with conditionals.  When comparing something with the null string `""'
using `ifeq' or `ifneq', you usually want a string of just whitespace
to match the null string.  Thus,

     .PHONY: all
     ifneq   "$(needs_made)" ""
     all: $(needs_made)
     else
     all:;@echo 'Nothing to make!'
     endif

might fail to have the desired results.  Replacing the variable
reference `"$(needs_made)"' with the function call `"$(strip
$(needs_made))"' in the `ifneq' directive would make it more robust.


File: make.info,  Node: Filename Functions,  Next: Foreach Function,  Prev: Text Functions,  Up: Functions

Functions for File Names
========================

   Several of the built-in expansion functions relate specifically to
taking apart file names or lists of file names.

   Each of the following functions performs a specific transformation
on a file name.  The argument of the function is regarded as a series
of file names, separated by whitespace.  (Leading and trailing
whitespace is ignored.)  Each file name in the series is transformed
in the same way and the results are concatenated with single spaces
between them.

`$(dir NAMES)'
     Extracts the directory-part of each file name in NAMES.  The
     directory-part of the file name is everything up through (and
     including) the last slash in it.  If the file name contains no
     slash, the directory part is the string `./'.  For example,

          $(dir src/foo.c hacks)

          produces the result `src/ ./'.

`$(notdir NAMES)'
     Extracts all but the directory-part of each file name in NAMES. 
     If the file name contains no slash, it is left unchanged. 
     Otherwise, everything through the last slash is removed from it.

     A file name that ends with a slash becomes an empty string.  This
     is unfortunate, because it means that the result does not always
     have the same number of whitespace-separated file names as the
     argument had; but we do not see any other valid alternative.

     For example,

          $(notdir src/foo.c hacks)

          produces the result `foo.c hacks'.

`$(suffix NAMES)'
     Extracts the suffix of each file name in NAMES.  If the file name
     contains a period, the suffix is everything starting with the last
     period.  Otherwise, the suffix is the empty string.  This
     frequently means that the result will be empty when NAMES is not,
     and if NAMES contains multiple file names, the result may contain
     fewer file names.

     For example,

          $(suffix src/foo.c hacks)

          produces the result `.c'.

`$(basename NAMES)'
     Extracts all but the suffix of each file name in NAMES.  If the
     file name contains a period, the basename is everything starting
     up to (and not including) the last period.  Otherwise, the
     basename is the entire file name.  For example,

          $(basename src/foo.c hacks)

          produces the result `src/foo hacks'.

`$(addsuffix SUFFIX,NAMES)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace; SUFFIX is used as a unit.  The value of SUFFIX is
     appended to the end of each individual name and the resulting
     larger names are concatenated with single spaces between them. 
     For example,

          $(addsuffix .c,foo bar)

          produces the result `foo.c bar.c'.

`$(addprefix PREFIX,NAMES)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace; PREFIX is used as a unit.  The value of PREFIX is
     appended to the front of each individual name and the resulting
     larger names are concatenated with single spaces between them. 
     For example,

          $(addprefix src/,foo bar)

          produces the result `src/foo src/bar'.

`$(join LIST1,LIST2)'
     Concatenates the two arguments word by word: the two first words
     (one from each argument) concatenated form the first word of the
     result, the two second words form the second word of the result,
     and so on.  So the Nth word of the result comes from the Nth word
     of each argument.  If one argument has more words that the other,
     the extra words are copied unchanged into the result.

     For example, `$(join a b,.c .o)' produces `a.c b.o'.

     Whitespace between the words in the lists is not preserved; it is
     replaced with a single space.

     This function can merge the results of the `dir' and `notdir'
     functions, to produce the original list of files which was given
     to those two functions.

`$(word N,TEXT)'
     Returns the Nth word of TEXT.  The legitimate values of N start
     from 1.  If N is bigger than the number of words in TEXT, the
     value is empty.  For example,

          $(word 2, foo bar baz)

          returns `bar'.

`$(words TEXT)'
     Returns the number of words in TEXT.  Thus, `$(word $(words
     TEXT),TEXT)' is the last word of TEXT.

`$(firstword NAMES)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace.  The value is the first name in the series.  The rest
     of the names are ignored.  For example,

          $(firstword foo bar)

          produces the result `foo'.  Although `$(firstword TEXT)' is the
     same as `$(word 1,TEXT)', the `firstword' function is retained
     for its simplicity.

`$(wildcard PATTERN)'
     The argument PATTERN is a file name pattern, typically containing
     wildcard characters.  The result of `wildcard' is a
     space-separated list of the names of existing files that match
     the pattern.

     Wildcards are expanded automatically in rules.  *Note Wildcards::. 
     But they are not normally expanded when a variable is set, or
     inside the arguments of other functions.  Those occasions are
     when the `wildcard' function is useful.

