'\"
'\" Copyright 1989-1992 Regents of the University of California
'\" Permission to use, copy, modify, and distribute this
'\" documentation for any purpose and without fee is hereby
'\" granted, provided that this notice appears in all copies.
'\" The University of California makes no representations about
'\" the suitability of this material for any purpose.  It is
'\" provided "as is" without express or implied warranty.
'\" 
'\" $Header: /user6/ouster/tcl/man/RCS/AssembCmd.3,v 1.3 92/12/09 17:01:03 ouster Exp $ SPRITE (Berkeley)
'\" 
.\" The definitions below are for supplemental macros used in Sprite
.\" manual entries.
.\"
.\" .HS name section [date [version]]
.\"	Replacement for .TH in other man pages.  See below for valid
.\"	section names.
.\"
.\" .AP type name in/out [indent]
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS [type [name]]
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .VS
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
'\"	# Heading for Sprite man pages
.de HS
.if '\\$2'cmds'       .TH \\$1 1 \\$3 \\$4
.if '\\$2'lib'        .TH \\$1 3 \\$3 \\$4
.if '\\$2'tcl'        .TH \\$1 3 \\$3 \\$4
.if '\\$2'tk'         .TH \\$1 3 \\$3 \\$4
.if t .wh -1.3i ^B
.nr ^l \\n(.l
.ad b
..
'\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ie !"\\$3"" \{\
.ta \\n()Au \\n()Bu
\&\\$1	\\fI\\$2\\fP	(\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
'\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
'\"	# BS - start boxed text
'\"	# ^y = starting y location
'\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
'\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
'\"	# VS - start vertical sidebar
'\"	# ^Y = starting y location
'\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
'\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
'\"	# Special macro to handle page bottom:  finish off current
'\"	# box/sidebar if in box/sidebar mode, then invoked standard
'\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
'\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
'\"	# DE - end display
.de DE
.fi
.RE
.sp .5
..
.HS Tcl_AssembleCmd tcl
.BS
.SH NAME
Tcl_CreateCmdBuf, Tcl_AssembleCmd, Tcl_DeleteCmdBuf \- buffer pieces of Tcl commands
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_CmdBuf
\fBTcl_CreateCmdBuf\fR()
.sp
\fBTcl_DeleteCmdBuf\fR(\fIbuffer\fR)
.sp
char *
.VS
\fBTcl_AssembleCmd\fR(\fIbuffer\fR, \fIstring\fR)
.VE
.sp
int
\fBTcl_CommandComplete\fR(\fIcmd\fR)
.SH ARGUMENTS
.AS Tcl_CmdBuf *string;
.AP Tcl_CmdBuf buffer in
Token for a command buffer (the result of some previous call to
\fBTcl_CreateCmdBuf\fR).
.AP char *string in
Additional piece of command input to be added to anything currently
buffered.
.AP char *cmd in
.VS
Command string to test for completeness.
.VE
.BE

.SH DESCRIPTION
.PP
These procedures provide a convenient mechanism for assembling
Tcl commands from an input source where command boundaries are not
obvious.  For example, if input is being read from a terminal, a user
may type commands that span multiple lines.  In situations like
this, \fBTcl_AssembleCmd\fR can be called with the individual lines
as they are received.  It buffers the lines internally and returns
full commands when they are complete.
.PP
A command buffer is created by calling \fBTcl_CreateCmdBuf\fR, and
it is deleted by calling \fBTcl_DeleteCmdBuf\fR.  There may be any
number of command buffers for a particular program or even for a
particular interpreter;  in most cases there should be one
buffer for each independent source of command input.
.PP
When input arrives from a source you should call \fBTcl_AssembleCmd\fR,
passing it the new input as the \fIstring\fR argument.
\fBTcl_AssembleCmd\fR will add the new input to anything currently
buffered in \fIbuffer\fR.  If the information now buffered represents
a complete Tcl command (i.e. there are no unclosed quotes, braces,
brackets, or variable references),
then \fBTcl_AssembleCmd\fR returns a pointer to the complete command
and arranges for the buffer to be cleared on the next call to
\fBTcl_AssembleCmd\fR.  If the command is still incomplete (because,
for example, there are unmatched braces) then \fBTcl_AssembleCmd\fR
returns NULL.  \fBTcl_AssembleCmd\fR keeps a private copy of the
command being assembled, so that the caller need not preserve the
contents of \fIstring\fR between calls to \fBTcl_AssembleCmd\fR.
\fBTcl_AssembleCmd\fR supports commands of arbitrary length (up to
the total memory limit imposed by the operating system, if any).
.PP
.VS
The procedure \fBTcl_CommandComplete\fR takes a Tcl command string
as argument and determines whether the command string is complete
in the sense defined above.
If so then it returns 1; otherwise it returns 0.
.VE

.SH KEYWORDS
assemble, buffer, partial command
