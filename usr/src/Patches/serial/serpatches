Patch to linux 0.99p1 to significantly improve the serial driver.
 
Before applying this patch, you will need to move move kernel/chr_drv/serial.c
to kernel/chr_drv/serial.c.old.
 
Please let me (tytso@mit.edu) know if you have any problems.
 
					Theodore Ts'o, 1/1/93
 
*** 1.1	1993/01/02 22:20:10
--- include/linux/tty.h	1993/01/09 12:31:07
***************
*** 76,82 ****
  	int	flags;
  	int	xmit_fifo_size;
  	int	custom_divisor;
! 	int	reserved[8];
  };
  
  /*
--- 76,83 ----
  	int	flags;
  	int	xmit_fifo_size;
  	int	custom_divisor;
! 	int	baud_base;
! 	int	reserved[7];
  };
  
  /*
***************
*** 92,98 ****
  /*
   * Definitions for async_struct (and serial_struct) flags field
   */
- #define ASYNC_NOSCRATCH	0x0001	/* 16XXX UART with no scratch register */
  #define ASYNC_FOURPORT  0x0002	/* Set OU1, OUT2 per AST Fourport settings */
  #define ASYNC_SAK	0x0004	/* Secure Attention Key (Orange book) */
  
--- 93,98 ----
***************
*** 101,108 ****
  #define ASYNC_SPD_VHI	0x0020  /* Use 115200 instead of 38400 bps */
  #define ASYNC_SPD_CUST	0x0030  /* Use user-specified divisor */
  
! #define ASYNC_FLAGS	0x0037	/* Possible legal async flags */
  
  #define IS_A_CONSOLE(min)	(((min) & 0xC0) == 0x00)
  #define IS_A_SERIAL(min)	(((min) & 0xC0) == 0x40)
  #define IS_A_PTY(min)		((min) & 0x80)
--- 101,111 ----
  #define ASYNC_SPD_VHI	0x0020  /* Use 115200 instead of 38400 bps */
  #define ASYNC_SPD_CUST	0x0030  /* Use user-specified divisor */
  
! #define ASYNC_FLAGS	0x0036	/* Possible legal async flags */
  
+ /* Internal flags used only by kernel/chr_drv/serial.c */
+ #define ASYNC_NO_IRQ	0x80000000 /* No IRQ was initialized */
+ 
  #define IS_A_CONSOLE(min)	(((min) & 0xC0) == 0x00)
  #define IS_A_SERIAL(min)	(((min) & 0xC0) == 0x40)
  #define IS_A_PTY(min)		((min) & 0x80)
***************
*** 194,199 ****
--- 197,203 ----
  	int  (*ioctl)(struct tty_struct *tty, struct file * file,
  		    unsigned int cmd, unsigned int arg);
  	void (*throttle)(struct tty_struct * tty, int status);
+ 	void (*set_termios)(struct tty_struct *tty, struct termios * old);
  	struct tty_struct *link;
  	struct tty_queue read_q;
  	struct tty_queue write_q;
***************
*** 244,249 ****
--- 248,254 ----
  #define TTY_CR_PENDING 2
  #define TTY_SQ_THROTTLED 3
  #define TTY_RQ_THROTTLED 4
+ #define TTY_IO_ERROR 5
  
  #define TTY_WRITE_FLUSH(tty) tty_write_flush((tty))
  #define TTY_READ_FLUSH(tty) tty_read_flush((tty))
*** 1.1	1993/01/02 22:20:42
--- kernel/chr_drv/tty_io.c	1993/01/02 22:20:56
***************
*** 732,738 ****
  	}
  	dev = MINOR(dev);
  	tty = TTY_TABLE(dev);
! 	if (!tty)
  		return -EIO;
  	if (MINOR(inode->i_rdev) && (tty->pgrp > 0) &&
  	    (current->tty == dev) &&
--- 732,738 ----
  	}
  	dev = MINOR(dev);
  	tty = TTY_TABLE(dev);
! 	if (!tty || (tty->flags & (1 << TTY_IO_ERROR)))
  		return -EIO;
  	if (MINOR(inode->i_rdev) && (tty->pgrp > 0) &&
  	    (current->tty == dev) &&
***************
*** 765,771 ****
  		tty = redirect;
  	else
  		tty = TTY_TABLE(dev);
! 	if (!tty || !tty->write)
  		return -EIO;
  	if (!is_console && L_TOSTOP(tty) && (tty->pgrp > 0) &&
  	    (current->tty == dev) && (tty->pgrp != current->pgrp)) {
--- 765,771 ----
  		tty = redirect;
  	else
  		tty = TTY_TABLE(dev);
! 	if (!tty || !tty->write || (tty->flags & (1 << TTY_IO_ERROR)))
  		return -EIO;
  	if (!is_console && L_TOSTOP(tty) && (tty->pgrp > 0) &&
  	    (current->tty == dev) && (tty->pgrp != current->pgrp)) {
*** 1.1	1993/01/09 12:27:08
--- kernel/chr_drv/tty_ioctl.c	1993/01/09 13:11:02
***************
*** 123,129 ****
  			int channel)
  {
  	int i;
! 	unsigned short old_cflag = tty->termios->c_cflag;
  
  	/* If we try to set the state of terminal and we're not in the
  	   foreground, send a SIGTTOU.  If the signal is blocked or
--- 123,129 ----
  			int channel)
  {
  	int i;
! 	struct termios	old_termios = *tty->termios;
  
  	/* If we try to set the state of terminal and we're not in the
  	   foreground, send a SIGTTOU.  If the signal is blocked or
***************
*** 139,146 ****
  	}
  	for (i=0 ; i< (sizeof (*termios)) ; i++)
  		((char *)tty->termios)[i]=get_fs_byte(i+(char *)termios);
- 	if (IS_A_SERIAL(channel) && tty->termios->c_cflag != old_cflag)
- 		change_speed(channel-64);
  
  	/* puting mpty's into echo mode is very bad, and I think under
  	   some situations can cause the kernel to do nothing but
--- 139,144 ----
***************
*** 147,152 ****
--- 145,153 ----
  	   copy characters back and forth. -RAB */
  	if (IS_A_PTY_MASTER(channel)) tty->termios->c_lflag &= ~ECHO;
  
+ 	if (tty->set_termios)
+ 		(tty->set_termios)(tty, &old_termios);
+ 
  	return 0;
  }
  
***************
*** 176,182 ****
  {
  	int i;
  	struct termio tmp_termio;
! 	unsigned short old_cflag = tty->termios->c_cflag;
  
  	if ((current->tty == channel) &&
  	    (tty->pgrp > 0) &&
--- 177,183 ----
  {
  	int i;
  	struct termio tmp_termio;
! 	struct termios old_termios = *tty->termios;
  
  	if ((current->tty == channel) &&
  	    (tty->pgrp > 0) &&
***************
*** 213,220 ****
  	tty->termios->c_line = tmp_termio.c_line;
  	for(i=0 ; i < NCC ; i++)
  		tty->termios->c_cc[i] = tmp_termio.c_cc[i];
! 	if (IS_A_SERIAL(channel) && tty->termios->c_cflag != old_cflag)
! 		change_speed(channel-64);
  	return 0;
  }
  
--- 214,223 ----
  	tty->termios->c_line = tmp_termio.c_line;
  	for(i=0 ; i < NCC ; i++)
  		tty->termios->c_cc[i] = tmp_termio.c_cc[i];
! 
! 	if (tty->set_termios)
! 		(tty->set_termios)(tty, &old_termios);
! 
  	return 0;
  }
  
*** 1.1	1993/01/02 22:20:42
--- include/linux/serial.h	1993/01/02 22:20:56
***************
*** 8,31 ****
   */
  
  /*
-  * This our internal structure for keeping track of interrupt service
-  * routines. 
-  */
- typedef struct struct_ISR *async_ISR;
- struct struct_ISR {
- 	int		irq;		/* The IRQ assigned for this device */
- 	int		port;		/* The base port for this device */
- 					/* (use is ISR specific) */
- 	void		(*ISR_proc)(async_ISR, int);
- 	int		line;		/* The serial line (or base */
- 					/* serial line)  */
- 	int		refcnt;		/* How many devices are depending on */
- 					/* this interrupt (multiport boards) */
- 	async_ISR	next_ISR; /* For the linked list */
- 	async_ISR	prev_ISR;
- };
- 
- /*
   * This is our internal structure for each serial port's state.
   * 
   * Many fields are paralleled by the structure used by the serial_struct
--- 8,13 ----
***************
*** 37,43 ****
  struct async_struct {
  	int			baud_base;
  	int			port;
! 	async_ISR		ISR;
  	int			flags;
  	int			type;
  	struct tty_struct 	*tty;
--- 19,25 ----
  struct async_struct {
  	int			baud_base;
  	int			port;
! 	int			irq;
  	int			flags;
  	int			type;
  	struct tty_struct 	*tty;
***************
*** 48,53 ****
--- 30,38 ----
  	int			x_char;	/* xon/xoff characater */
  	int			event;
  	int			line;
+ 	struct async_struct	*next_port; /* For the linked list */
+ 	struct async_struct	*prev_port;
+ 	
  };
  
  /*
***************
*** 92,98 ****
  #define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
  
  #define UART_FCR_CLEAR_CMD	(UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT)
! #define UART_FCR_SETUP_CMD	(UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_14)
  	
  /*
   * These are the definitions for the Line Control Register
--- 77,83 ----
  #define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
  
  #define UART_FCR_CLEAR_CMD	(UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT)
! #define UART_FCR_SETUP_CMD	(UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8)
  	
  /*
   * These are the definitions for the Line Control Register
*** 1.1	1993/01/02 22:20:42
--- kernel/chr_drv/serial.c	1993/01/11 01:37:20
***************
*** 6,14 ****
   *  Extensively rewritten by Theodore Ts'o, 8/16/92 -- 9/14/92.  Now
   *  much more extensible to support other serial cards based on the
   *  16450/16550A UART's.  Added support for the AST FourPort and the
!  *  Accent Async board.  We use the async_ISR structure to allow
!  *  multiple ports (or boards, if the hardware permits) to share a
!  *  single IRQ channel.
   *
   *  set_serial_info fixed to set the flags, custom divisor, and uart
   * 	type fields.  Fix suggested by Michael K. Johnson 12/12/92.
--- 6,12 ----
   *  Extensively rewritten by Theodore Ts'o, 8/16/92 -- 9/14/92.  Now
   *  much more extensible to support other serial cards based on the
   *  16450/16550A UART's.  Added support for the AST FourPort and the
!  *  Accent Async board.  
   *
   *  set_serial_info fixed to set the flags, custom divisor, and uart
   * 	type fields.  Fix suggested by Michael K. Johnson 12/12/92.
***************
*** 26,32 ****
--- 24,32 ----
  #include <linux/timer.h>
  #include <linux/tty.h>
  #include <linux/serial.h>
+ #include <linux/interrupt.h>
  #include <linux/config.h>
+ #include <linux/string.h>
  
  #include <asm/system.h>
  #include <asm/io.h>
***************
*** 42,55 ****
   * 		cleanly than it used to in 0.98pl2-6.  It should be
   * 		much less vulnerable to false IRQ's now.
   * 
-  * NEW_INTERRUPT_ROUTINE
-  * 		Enables the new interrupt routine, which is faster
-  * 		(which is better on slow CPU's), and handles parity
-  * 		errors, break conditions, and hardware handshaking.
-  * 		People were having problems with it earlier, but I
-  * 		believe they have been fixed now, so there should
-  * 		hopefully be no reason to #undef this option.
-  * 
   * CONFIG_AST_FOURPORT
   *		Enables support for the AST Fourport serial port.
   * 
--- 42,47 ----
***************
*** 59,66 ****
   * 
   */
  	
- #undef NEW_INTERRUPT_ROUTINE
- 	
  #define WAKEUP_CHARS (3*TTY_BUF_SIZE/4)
  
  /*
--- 51,56 ----
***************
*** 70,101 ****
   * 				transmitting (and therefore have a
   * 				write timeout pending, in case the
   * 				THRE interrupt gets lost.)
!  * IRQ_ISR[]		- Array to store the head of the ISR linked list
!  * 				for each IRQ.
   */
! static unsigned long rs_event = 0;
! static unsigned long rs_write_active = 0;
! 
! static async_ISR IRQ_ISR[16];
! 
! static void UART_ISR_proc(async_ISR ISR, int line);
! 
! struct struct_ISR COM1_ISR = { 4, 0x3f8, UART_ISR_proc, 0, };
! struct struct_ISR COM2_ISR = { 3, 0x2f8, UART_ISR_proc, 0, };
! struct struct_ISR COM3_ISR = { 4, 0x3e8, UART_ISR_proc, 0, };
! struct struct_ISR COM4_ISR = { 3, 0x2e8, UART_ISR_proc, 0, };
! 
! #ifdef CONFIG_AST_FOURPORT
! static void FourPort_ISR_proc(async_ISR ISR, int line);
  
! struct struct_ISR FourPort1_ISR = { 2, 0x1bf, FourPort_ISR_proc, 0, };
! struct struct_ISR FourPort2_ISR = { 5, 0x2bf, FourPort_ISR_proc, 0, };
! #endif
! 
! #ifdef CONFIG_ACCENT_ASYNC
! struct struct_ISR Accent3_ISR = { 4, 0x330, UART_ISR_proc, 0, };
! struct struct_ISR Accent4_ISR = { 4, 0x338, UART_ISR_proc, 0, };
! #endif
  
  /*
   * This assumes you have a 1.8432 MHz clock for your UART.
--- 60,73 ----
   * 				transmitting (and therefore have a
   * 				write timeout pending, in case the
   * 				THRE interrupt gets lost.)
!  *
!  * We assume here that int's are 32 bits, so an array of two gives us
!  * 64 lines, which is the maximum we can support.
   */
! static int rs_event[2];
! static int rs_write_active[2];
  
! static struct async_struct *IRQ_ports[16];
  
  /*
   * This assumes you have a 1.8432 MHz clock for your UART.
***************
*** 107,148 ****
  #define BASE_BAUD ( 1843200 / 16 ) 
  
  struct async_struct rs_table[] = {
! 	{ BASE_BAUD, 0x3F8, &COM1_ISR, 0, },
! 	{ BASE_BAUD, 0x2F8, &COM2_ISR, 0, },
! 	{ BASE_BAUD, 0x3E8, &COM3_ISR, 0, },
! 	{ BASE_BAUD, 0x2E8, &COM4_ISR, 0, },
  #ifdef CONFIG_AST_FOURPORT
! 	{ BASE_BAUD, 0x1A0, &FourPort1_ISR, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x1A8, &FourPort1_ISR, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x1B0, &FourPort1_ISR, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x1B8, &FourPort1_ISR, ASYNC_FOURPORT | ASYNC_NOSCRATCH },
! 
! 	{ BASE_BAUD, 0x2A0, &FourPort2_ISR, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x2A8, &FourPort2_ISR, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x2B0, &FourPort2_ISR, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x2B8, &FourPort2_ISR, ASYNC_FOURPORT | ASYNC_NOSCRATCH },
  #else /* CONFIG_AST_FOURPORT */
! 	{ BASE_BAUD, 0x000 }, 
! 	{ BASE_BAUD, 0x000 }, 
! 	{ BASE_BAUD, 0x000 },
! 	{ BASE_BAUD, 0x000 }, 
! 
! 	{ BASE_BAUD, 0x000 },
! 	{ BASE_BAUD, 0x000 }, 
! 	{ BASE_BAUD, 0x000 },
! 	{ BASE_BAUD, 0x000 },
  #endif /* CONFIG_AST_FOURPORT */
  	
  #ifdef CONFIG_ACCENT_ASYNC
! 	{ BASE_BAUD, 0x330, &Accent3_ISR, 0 },
! 	{ BASE_BAUD, 0x338, &Accent4_ISR, 0 },
  #else /* CONFIG_ACCENT_ASYNC */
! 	{ BASE_BAUD, 0x000 },
! 	{ BASE_BAUD, 0x000 },
  #endif /* CONFIG_ACCENT_ASYNC */
! 	{ BASE_BAUD, 0x000 },
! 	{ BASE_BAUD, 0x000 },
! 	
  };
  
  #define NR_PORTS	(sizeof(rs_table)/sizeof(struct async_struct))
--- 79,136 ----
  #define BASE_BAUD ( 1843200 / 16 ) 
  
  struct async_struct rs_table[] = {
! 	{ BASE_BAUD, 0x3F8, 4, 0, },
! 	{ BASE_BAUD, 0x2F8, 3, 0, },
! 	{ BASE_BAUD, 0x3E8, 4, 0, },
! 	{ BASE_BAUD, 0x2E8, 3, 0, },
  #ifdef CONFIG_AST_FOURPORT
! 	{ BASE_BAUD, 0x1A0, 2, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x1A8, 2, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x1B0, 2, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x1B8, 2, ASYNC_FOURPORT },
! 
! 	{ BASE_BAUD, 0x2A0, 5, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x2A8, 5, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x2B0, 5, ASYNC_FOURPORT },
! 	{ BASE_BAUD, 0x2B8, 5, ASYNC_FOURPORT },
  #else /* CONFIG_AST_FOURPORT */
! 	{ BASE_BAUD, 0x000, 0 }, 
! 	{ BASE_BAUD, 0x000, 0 }, 
! 	{ BASE_BAUD, 0x000, 0 },
! 	{ BASE_BAUD, 0x000, 0 }, 
! 
! 	{ BASE_BAUD, 0x000, 0 },
! 	{ BASE_BAUD, 0x000, 0 }, 
! 	{ BASE_BAUD, 0x000, 0 },
! 	{ BASE_BAUD, 0x000, 0 },
  #endif /* CONFIG_AST_FOURPORT */
  	
  #ifdef CONFIG_ACCENT_ASYNC
! 	{ BASE_BAUD, 0x330, 4, 0 },
! 	{ BASE_BAUD, 0x338, 4, 0 },
  #else /* CONFIG_ACCENT_ASYNC */
! 	{ BASE_BAUD, 0x000, 0 },
! 	{ BASE_BAUD, 0x000, 0 },
  #endif /* CONFIG_ACCENT_ASYNC */
! 	{ BASE_BAUD, 0x000, 0 },
! 	{ BASE_BAUD, 0x000, 0 },
! 
! 	{ BASE_BAUD, 0x100, 4, 0 },
! 	{ BASE_BAUD, 0x108, 4, 0 },
! 	{ BASE_BAUD, 0x110, 4, 0 },
! 	{ BASE_BAUD, 0x118, 4, 0 },
! 	{ BASE_BAUD, 0x120, 4, 0 },
! 	{ BASE_BAUD, 0x128, 4, 0 },
! 	{ BASE_BAUD, 0x130, 4, 0 },
! 	{ BASE_BAUD, 0x138, 4, 0 },
! 	{ BASE_BAUD, 0x140, 4, 0 },
! 	{ BASE_BAUD, 0x148, 4, 0 },
! 	{ BASE_BAUD, 0x150, 4, 0 },
! 	{ BASE_BAUD, 0x158, 4, 0 },
! 	{ BASE_BAUD, 0x160, 4, 0 },
! 	{ BASE_BAUD, 0x168, 4, 0 },
! 	{ BASE_BAUD, 0x170, 4, 0 },
! 	{ BASE_BAUD, 0x178, 4, 0 },
  };
  
  #define NR_PORTS	(sizeof(rs_table)/sizeof(struct async_struct))
***************
*** 152,207 ****
   */
  static int baud_table[] = {
  	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
! 	9600, 19200, 38400, 56000, 115200, 0 };
  
  static void startup(struct async_struct * info);
  static void shutdown(struct async_struct * info);
  static void rs_throttle(struct tty_struct * tty, int status);
  
! static void send_break(	struct async_struct * info)
  {
! 	unsigned short port;
  
! 	if (!(port = info->port))
  		return;
- 	port += UART_LCR;
  	current->state = TASK_INTERRUPTIBLE;
  	current->timeout = jiffies + 25;
! 	outb_p(inb_p(port) | UART_LCR_SBC, port);
  	schedule();
! 	outb(inb_p(port) & ~UART_LCR_SBC, port);
  }
  
! static inline void rs_sched_event(int line,
! 				  struct async_struct *info,
  				  int event)
  {
  	info->event |= 1 << event;
! 	rs_event |= 1 << line;
! 	timer_table[RS_TIMER].expires = 0;
! 	timer_active |= 1 << RS_TIMER;
  }
  
! #ifdef NEW_INTERRUPT_ROUTINE
  /*
!  * This ISR handles the COM1-4 8250, 16450, and 16550A UART's.  It is
!  * also called by the FourPort ISR, since the FourPort also uses the
!  * same National Semiconduct UART's, with some interrupt multiplexing
!  * thrown in.
!  * 
!  * This routine assumes nobody else will be mucking with the tty
!  * queues its working on.  It should be called with the interrupts
!  * disabled, since it is not reentrant, and it assumes it doesn't need
!  * to worry about other routines mucking about its data structures
!  * while it keeps copies of critical pointers in registers.
   */
! static void UART_ISR_proc(async_ISR ISR, int line)
  {
  	unsigned char status;
! 	struct async_struct * info = rs_table + line;
  	struct tty_queue * queue;
  	int head, tail, count, ch;
! 	int cflag, iflag;
  	
  	/*
  	 * Just like the LEFT(x) macro, except it uses the loal tail
--- 140,203 ----
   */
  static int baud_table[] = {
  	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
! 	9600, 19200, 38400, 56700, 115200, 0 };
  
  static void startup(struct async_struct * info);
  static void shutdown(struct async_struct * info);
  static void rs_throttle(struct tty_struct * tty, int status);
+ static void restart_port(struct async_struct *info);
  
! static inline unsigned int serial_in(struct async_struct *info, int offset)
  {
! 	return inb(info->port + offset);
! }
  
! static inline unsigned int serial_inp(struct async_struct *info, int offset)
! {
! 	return inb_p(info->port + offset);
! }
! 
! static inline void serial_out(struct async_struct *info, int offset, int value)
! {
! 	outb(value, info->port+offset);
! }
! 
! static inline void serial_outp(struct async_struct *info, int offset,
! 			       int value)
! {
! 	outb_p(value, info->port+offset);
! }
! 
! static void send_break(	struct async_struct * info)
! {
! 	if (!info->port)
  		return;
  	current->state = TASK_INTERRUPTIBLE;
  	current->timeout = jiffies + 25;
! 	serial_out(info, UART_LCR, serial_inp(info, UART_LCR) | UART_LCR_SBC);
  	schedule();
! 	serial_out(info, UART_LCR, serial_inp(info, UART_LCR) & ~UART_LCR_SBC);
  }
  
! static inline void rs_sched_event(struct async_struct *info,
  				  int event)
  {
  	info->event |= 1 << event;
! 	set_bit(info->line, rs_event);
! 	mark_bh(SERIAL_BH);
  }
  
! 
  /*
!  * This is the serial driver's generic interrupt routine
   */
! static void rs_interrupt(int irq)
  {
  	unsigned char status;
! 	struct async_struct * info;
  	struct tty_queue * queue;
  	int head, tail, count, ch;
! 	int done;
  	
  	/*
  	 * Just like the LEFT(x) macro, except it uses the loal tail
***************
*** 208,228 ****
  	 * and head variables.
  	 */
  #define VLEFT ((tail-head-1)&(TTY_BUF_SIZE-1))
  
! 	if (!info || !info->tty || !info->port)
! 		return;
! 	cflag = info->tty->termios->c_cflag;
! 	iflag = info->tty->termios->c_iflag;
! 	
! 	do {
! 	restart:
! 		status = inb_p(UART_LSR + info->port);
  		if (status & UART_LSR_DR) {
  			queue = &info->tty->read_q;
  			head = queue->head;
  			tail = queue->tail;
  			do {
! 				ch = inb(UART_RX + info->port);
  				/*
  				 * There must be at least 3 characters
  				 * free in the queue; otherwise we punt.
--- 204,232 ----
  	 * and head variables.
  	 */
  #define VLEFT ((tail-head-1)&(TTY_BUF_SIZE-1))
+ #define IFLAG (info->tty->termios->c_iflag)
+ #define CFLAG (info->tty->termios->c_cflag)
  
! 	info = IRQ_ports[irq];
! 	done = 1;
! 	while (info) {
! #ifdef SERIAL_INT_DEBUG
! 		printk("rsint(%d)...", info->line);
! #endif
! 		if (serial_inp(info, UART_IIR) & UART_IIR_NO_INT)
! 			goto next_loop;
! 		done = 0;
! 		
! 		status = serial_inp(info, UART_LSR);
  		if (status & UART_LSR_DR) {
+ #ifdef SERIAL_INT_DEBUG
+ 			printk("DR...");
+ #endif
  			queue = &info->tty->read_q;
  			head = queue->head;
  			tail = queue->tail;
  			do {
! 				ch = serial_in(info, UART_RX);
  				/*
  				 * There must be at least 3 characters
  				 * free in the queue; otherwise we punt.
***************
*** 234,249 ****
  					      UART_LSR_PE)) {
  					if (status & (UART_LSR_BI)) {
  						if (info->flags & ASYNC_SAK)
! 			rs_sched_event(line, info, RS_EVENT_DO_SAK);
! 						else if (iflag & IGNBRK)
  							continue;
! 						else if (iflag & BRKINT) 
! 			rs_sched_event(line, info, RS_EVENT_BREAK_INT);
  						else
  							ch = 0;
! 					} else if (iflag & IGNPAR)
  						continue;
! 					if (iflag & PARMRK) {
  						queue->buf[head++] = 0xff;
  						head &= TTY_BUF_SIZE-1;
  						queue->buf[head++] = 0;
--- 238,253 ----
  					      UART_LSR_PE)) {
  					if (status & (UART_LSR_BI)) {
  						if (info->flags & ASYNC_SAK)
! 			rs_sched_event(info, RS_EVENT_DO_SAK);
! 						else if (IFLAG & IGNBRK)
  							continue;
! 						else if (IFLAG & BRKINT) 
! 			rs_sched_event(info, RS_EVENT_BREAK_INT);
  						else
  							ch = 0;
! 					} else if (IFLAG & IGNPAR)
  						continue;
! 					if (IFLAG & PARMRK) {
  						queue->buf[head++] = 0xff;
  						head &= TTY_BUF_SIZE-1;
  						queue->buf[head++] = 0;
***************
*** 250,268 ****
  						head &= TTY_BUF_SIZE-1;
  					} else
  						ch = 0;
! 				} else if ((iflag & PARMRK) && (ch == 0xff)) {
  					queue->buf[head++] = 0xff;
  					head &= TTY_BUF_SIZE-1;
  				}
  				queue->buf[head++] = ch;
  				head &= TTY_BUF_SIZE-1;
! 			} while ((status = inb_p(UART_LSR + info->port)) &
  				 UART_LSR_DR);
  			queue->head = head;
  			if ((VLEFT < RQ_THRESHOLD_LW)
  			    && !set_bit(TTY_RQ_THROTTLED, &info->tty->flags)) 
  				rs_throttle(info->tty, TTY_THROTTLE_RQ_FULL);
! 			rs_sched_event(line, info, RS_EVENT_READ_PROCESS);
  		}
  		if ((status & UART_LSR_THRE) &&
  		    !info->tty->stopped) {
--- 254,272 ----
  						head &= TTY_BUF_SIZE-1;
  					} else
  						ch = 0;
! 				} else if ((IFLAG & PARMRK) && (ch == 0xff)) {
  					queue->buf[head++] = 0xff;
  					head &= TTY_BUF_SIZE-1;
  				}
  				queue->buf[head++] = ch;
  				head &= TTY_BUF_SIZE-1;
! 			} while ((status = serial_inp(info, UART_LSR)) &
  				 UART_LSR_DR);
  			queue->head = head;
  			if ((VLEFT < RQ_THRESHOLD_LW)
  			    && !set_bit(TTY_RQ_THROTTLED, &info->tty->flags)) 
  				rs_throttle(info->tty, TTY_THROTTLE_RQ_FULL);
! 			rs_sched_event(info, RS_EVENT_READ_PROCESS);
  		}
  		if ((status & UART_LSR_THRE) &&
  		    !info->tty->stopped) {
***************
*** 272,278 ****
  			if (head==tail && !info->x_char)
  				goto no_xmit;
  			if (info->x_char) {
! 				outb_p(info->x_char, UART_TX + info->port);
  				info->x_char = 0;
  			} else {
  				count = info->xmit_fifo_size;
--- 276,282 ----
  			if (head==tail && !info->x_char)
  				goto no_xmit;
  			if (info->x_char) {
! 				serial_outp(info, UART_TX, info->x_char);
  				info->x_char = 0;
  			} else {
  				count = info->xmit_fifo_size;
***************
*** 279,478 ****
  				while (count--) {
  					if (tail == head)
  						break;
! 					outb_p(queue->buf[tail++],
! 					       UART_TX + info->port);
  					tail &= TTY_BUF_SIZE-1;
  				}
  			}
  			queue->tail = tail;
  			if (VLEFT > WAKEUP_CHARS)
! 				rs_sched_event(line, info,
! 					       RS_EVENT_WRITE_WAKEUP);
  			info->timer = jiffies + info->timeout;
  			if (info->timer < timer_table[RS_TIMER].expires)
  				timer_table[RS_TIMER].expires = info->timer;
! #ifdef i386
! 			rs_write_active |= 1 << line;
! #else
! 			set_bit(line, &rs_write_active);
! #endif
  			timer_active |= 1 << RS_TIMER;
  		}
  	no_xmit:
! 		status = inb(UART_MSR + info->port);
  		
! 		if (!(cflag & CLOCAL) && (status & UART_MSR_DDCD)) {
  			if (!(status & UART_MSR_DCD))
! 				rs_sched_event(line, info, RS_EVENT_HUP_PGRP);
  		}
! 		/*
! 		 * Because of the goto statement, this block must be
! 		 * last.  We have to skip the do/while test condition
! 		 * because the THRE interrupt has probably been lost.
! 		 */
! 		if (cflag & CRTSCTS) {
  			if (info->tty->stopped) {
  				if (status & UART_MSR_CTS) {
  					info->tty->stopped = 0;
! 					goto restart;
  				}
  			} else 
  				info->tty->stopped = !(status & UART_MSR_CTS);
  		}
! 	} while (!(inb_p(UART_IIR + info->port) & UART_IIR_NO_INT));
! }
! #else /* NEW_INTERRUPT_ROUTINE */
! /*
!  * There are several races here: we avoid most of them by disabling
!  * timer_active for the crucial part of the process.. That's a good
!  * idea anyway. 
!  *
!  * The problem is that we have to output characters /both/ from interrupts
!  * and from the normal write: the latter to be sure the interrupts start up
!  * again. With serial lines, the interrupts can happen so often that the
!  * races actually are noticeable.
!  */
! static void send_intr(struct async_struct * info)
! {
! 	unsigned short port = info->port;
! 	int line = info->line;
! 	struct tty_queue * queue = &info->tty->write_q;
! 	int c, count = 0;
! 
! 	if (info->tty->stopped)
! 		return;
! 
! 	if (info->type == PORT_16550A)
! 		count = 16;	
! 	else
! 		count = 1;
! 	
! 	rs_write_active &= ~(1 << line);
! 
! 	if (inb_p(UART_LSR + info->port) & UART_LSR_THRE) {
! 		while (count-- && !info->tty->stopped) {
! 			if (queue->tail == queue->head)
! 				goto end_send;
! 			c = queue->buf[queue->tail];
! 			queue->tail++;
! 			queue->tail &= TTY_BUF_SIZE-1;
! 			outb(c, UART_TX + port);
! 		}
! 	}
! 	info->timer = jiffies + info->timeout;
! 	if (info->timer < timer_table[RS_TIMER].expires)
! 		timer_table[RS_TIMER].expires = info->timer;
! 	rs_write_active |= 1 << line;
! 	timer_active |= 1 << RS_TIMER;
! end_send:
! 	if (LEFT(queue) > WAKEUP_CHARS)
! 		wake_up(&queue->proc_list);
! }
! 
! static void receive_intr(struct async_struct * info)
! {
! 	unsigned short port = info->port;
! 	struct tty_queue * queue = &info->tty->read_q;
! 	int head = queue->head;
! 	int maxhead = (queue->tail-1) & (TTY_BUF_SIZE-1);
! 	int count = 0;
! 
! 	do {
! 		count++;
! 		queue->buf[head] = inb(UART_TX + port);
! 		if (head != maxhead) {
! 			head++;
! 			head &= TTY_BUF_SIZE-1;
! 		}
! 	} while (inb(UART_LSR + port) & UART_LSR_DR);
! 	queue->head = head;
! 	rs_sched_event(info->line, info, RS_EVENT_READ_PROCESS);
! }
! 
! static void line_status_intr(struct async_struct * info)
! {
! 	unsigned char status = inb(UART_LSR + info->port);
! 
! /*	printk("line status: %02x\n",status);  */
! }
! 
! static void modem_status_intr(struct async_struct * info)
! {
! 	unsigned char status = inb(UART_MSR + info->port);
! 
! 	if (!(info->tty->termios->c_cflag & CLOCAL)) {
! 		if ((status & (UART_MSR_DCD|UART_MSR_DDCD)) == UART_MSR_DDCD)
! 			tty_hangup(info->tty);
! 
! 		if (info->tty->termios->c_cflag & CRTSCTS)
! 			info->tty->stopped = !(status & UART_MSR_CTS);
! 
! 		if (!info->tty->stopped)
! 			send_intr(info);
! 	}
! }
! 
! static void (*jmp_table[4])(struct async_struct *) = {
! 	modem_status_intr,
! 	send_intr,
! 	receive_intr,
! 	line_status_intr
! };
! 
! /*
!  * This ISR handles the COM1-4 8250, 16450, and 16550A UART's.  It is
!  * also called by the FourPort ISR, since the FourPort also uses the
!  * same National Semiconduct UART's, with some interrupt multiplexing
!  * thrown in.
!  */
! static void UART_ISR_proc(async_ISR ISR, int line)
! {
! 	unsigned char ident;
! 	struct async_struct * info = rs_table + line;
! 
! 	if (!info || !info->tty || !info->port)
! 		  return;
! 	while (1) {
! 		ident = inb(UART_IIR + info->port) & 7;
! 		if (ident & 1)
! 			return;
! 		ident = ident >> 1;
! 		jmp_table[ident](info);
! 	}
! }
! #endif /* NEW_INTERRUPT_ROUTINE */
! 
! #ifdef CONFIG_AST_FOURPORT
! /*
!  * Here is the fourport ISR
!  */
! static void FourPort_ISR_proc(async_ISR ISR, int line)
! {
! 	int		i;
! 	unsigned char ivec;
! 
! 	ivec = ~inb(ISR->port) & 0x0F;
! 	do {
! 		for (i = line; ivec; i++) {
! 			if (ivec & 1)
! 				UART_ISR_proc(ISR, i);
! 			ivec = ivec >> 1;
  		}
- 		ivec = ~inb(ISR->port) & 0x0F;
- 	} while (ivec);
- }
- #endif /* CONFIG_AST_FOURPORT */
- 
- /*
-  * This is the serial driver's generic interrupt routine
-  */
- static void rs_interrupt(int irq)
- {
- 	async_ISR p = IRQ_ISR[irq];
- 
- 	while (p) {
- 		(p->ISR_proc)(p, p->line);
- 		p = p->next_ISR;
  	}
  }
  
--- 283,330 ----
  				while (count--) {
  					if (tail == head)
  						break;
! 					serial_outp(info, UART_TX,
! 						    queue->buf[tail++]);
  					tail &= TTY_BUF_SIZE-1;
  				}
  			}
  			queue->tail = tail;
  			if (VLEFT > WAKEUP_CHARS)
! 				rs_sched_event(info, RS_EVENT_WRITE_WAKEUP);
  			info->timer = jiffies + info->timeout;
  			if (info->timer < timer_table[RS_TIMER].expires)
  				timer_table[RS_TIMER].expires = info->timer;
! 			set_bit(info->line, rs_write_active);
  			timer_active |= 1 << RS_TIMER;
+ #ifdef SERIAL_INT_DEBUG
+ 			printk("THRE...");
+ #endif
  		}
  	no_xmit:
! 		status = serial_in(info, UART_MSR);
  		
! 		if (!(CFLAG & CLOCAL) && (status & UART_MSR_DDCD)) {
  			if (!(status & UART_MSR_DCD))
! 				rs_sched_event(info, RS_EVENT_HUP_PGRP);
  		}
! 		if (CFLAG & CRTSCTS) {
  			if (info->tty->stopped) {
  				if (status & UART_MSR_CTS) {
  					info->tty->stopped = 0;
! 					restart_port(info);
  				}
  			} else 
  				info->tty->stopped = !(status & UART_MSR_CTS);
  		}
! 	next_loop:
! 		info = info->next_port;
! 		if (!info && !done) {
! #ifdef SERIAL_INT_DEBUG
! 			printk("repeating...");
! #endif
! 			info = IRQ_ports[irq];
! 			done = 1;
  		}
  	}
  }
  
***************
*** 492,521 ****
  }
  #endif
  
! /*
!  * This subroutine handles all of the timer functionality required for
!  * the serial ports.
!  */
! 
! #define END_OF_TIME 0xffffffff
! static void rs_timer(void)
  {
! 	unsigned long		mask;
  	struct async_struct	*info;
! 	unsigned long		next_timeout;
! 
! 	info = rs_table;
! 	next_timeout = END_OF_TIME;
! 	for (mask = 1 ; mask ; info++, mask <<= 1) {
! 		if ((mask > rs_event) &&
! 		    (mask > rs_write_active))
! 			break;
! 		if (!info->tty) {	/* check that we haven't closed it.. */
! 			rs_event &= ~mask;
! 			rs_write_active &= ~mask;
! 			continue;
! 		}
! 		if (mask & rs_event) {
  			if (!clear_bit(RS_EVENT_READ_PROCESS, &info->event)) {
  				TTY_READ_FLUSH(info->tty);
  			}
--- 344,358 ----
  }
  #endif
  
! static void do_softint()
  {
! 	int			i;
  	struct async_struct	*info;
! 	
! 	for (i = 0, info = rs_table; i < NR_PORTS; i++,info++) {
! 		if (!clear_bit(i, rs_event)) {
! 			if (!info->tty)	
! 				continue;
  			if (!clear_bit(RS_EVENT_READ_PROCESS, &info->event)) {
  				TTY_READ_FLUSH(info->tty);
  			}
***************
*** 528,596 ****
  				flush_input(info->tty);
  				flush_output(info->tty);
  				if (info->tty->pgrp > 0)
! 					kill_pg(info->tty->pgrp,SIGINT,1);
  			}
  			if (!clear_bit(RS_EVENT_DO_SAK, &info->event)) {
  				do_SAK(info->tty);
  			}
- 			cli();
- 			if (info->event) 
- 				next_timeout = 0;
- 			else
- 				rs_event &= ~mask;
- 			sti();
- 		}
- 		if (mask & rs_write_active) {
- 			if (info->timer <= jiffies) {
- #ifdef i386
- 				rs_write_active &= ~mask;
- #else
- 				clear_bit(info->line, &rs_write_active);
- #endif
- 				rs_write(info->tty);
- 			}
- 			if ((mask & rs_write_active) &&
- 			    (info->timer < next_timeout))
- 				next_timeout = info->timer;
  		}
  	}
! 	if (next_timeout != END_OF_TIME) {
! 		timer_table[RS_TIMER].expires = next_timeout;
! #ifdef i386
! 		/*
! 		 * This must compile to a single, atomic instruction.
! 		 * It does using 386 with GCC; if you're not sure, use
! 		 * the set_bit function, which is supposed to be atomic.
! 		 */
! 		timer_active |= 1 << RS_TIMER;
! #else
! 		set_bit(RS_TIMER, &timer_active);
! #endif
  	}
  }
  
  /*
   * This routine gets called when tty_write has put something into
!  * the write_queue. It calls UART_ISR_proc to simulate an interrupt,
!  * which gets things going.
   */
  void rs_write(struct tty_struct * tty)
  {
  	struct async_struct *info;
  
! 	if (!tty || tty->stopped || EMPTY(&tty->write_q))
  		return;
  	info = rs_table + DEV_TO_SL(tty->line);
! 	if (!test_bit(info->line, &rs_write_active)) {
! 		cli();
! #ifdef NEW_INTERRUPT_ROUTINE
! 		UART_ISR_proc(info->ISR, info->line);
! #else
! 		send_intr(info);
! #endif
! 		sti();
! 	}
! 	
  }
  
  static void rs_throttle(struct tty_struct * tty, int status)
--- 365,439 ----
  				flush_input(info->tty);
  				flush_output(info->tty);
  				if (info->tty->pgrp > 0)
! 					kill_pg(info->tty->pgrp, SIGINT,1);
  			}
  			if (!clear_bit(RS_EVENT_DO_SAK, &info->event)) {
  				do_SAK(info->tty);
  			}
  		}
  	}
! }
! 
! /*
!  * This subroutine handles all of the timer functionality required for
!  * the serial ports.
!  */
! 
! static void rs_timer(void)
! {
! 	int			i;
! 	struct async_struct	*info;
! 
! 	for (i = 0, info = rs_table; i < NR_PORTS; i++,info++) {
! 		if (test_bit(i, rs_write_active) && (info->timer <= jiffies)) {
! 			clear_bit(i, rs_write_active);
! 			rs_write(info->tty);
! 		}
  	}
  }
  
  /*
+  * Note: this subroutine must be called with the interrupts *off*
+  */
+ static void restart_port(struct async_struct *info)
+ {
+ 	struct tty_queue * queue;
+ 	int head, tail, count;
+ 	
+ 	if (serial_inp(info, UART_LSR) & UART_LSR_THRE) {
+ 		if (info->x_char) {
+ 			serial_outp(info, UART_TX, info->x_char);
+ 			info->x_char = 0;
+ 		} else {
+ 			queue = &info->tty->write_q;
+ 			head = queue->head;
+ 			tail = queue->tail;
+ 			count = info->xmit_fifo_size;
+ 			while (count--) {
+ 				if (tail == head)
+ 					break;
+ 				serial_outp(info, UART_TX, queue->buf[tail++]);
+ 				tail &= TTY_BUF_SIZE-1;
+ 			}
+ 			queue->tail = tail;
+ 		}
+ 	}
+ }	
+ 
+ /*
   * This routine gets called when tty_write has put something into
!  * the write_queue.  
   */
  void rs_write(struct tty_struct * tty)
  {
  	struct async_struct *info;
  
! 	if (!tty || tty->stopped)
  		return;
  	info = rs_table + DEV_TO_SL(tty->line);
! 	cli();
! 	restart_port(info);
! 	sti();
  }
  
  static void rs_throttle(struct tty_struct * tty, int status)
***************
*** 608,616 ****
  		if (tty->termios->c_iflag & IXOFF) {
  			info->x_char = STOP_CHAR(tty);
  		} else {
! 			mcr = inb_p(UART_MCR + info->port);
  			mcr &= ~UART_MCR_RTS;
! 			outb(mcr, UART_MCR + info->port);
  		}
  		break;
  	case TTY_THROTTLE_RQ_AVAIL:
--- 451,459 ----
  		if (tty->termios->c_iflag & IXOFF) {
  			info->x_char = STOP_CHAR(tty);
  		} else {
! 			mcr = serial_inp(info, UART_MCR);
  			mcr &= ~UART_MCR_RTS;
! 			serial_out(info, UART_MCR, mcr);
  		}
  		break;
  	case TTY_THROTTLE_RQ_AVAIL:
***************
*** 623,631 ****
  				info->x_char = START_CHAR(tty);
  			sti();
  		} else {
! 			mcr = inb(UART_MCR + info->port);
  			mcr |= UART_MCR_RTS;
! 			outb_p(mcr, UART_MCR + info->port);
  		}
  		break;
  	}
--- 466,474 ----
  				info->x_char = START_CHAR(tty);
  			sti();
  		} else {
! 			mcr = serial_in(info, UART_MCR);
  			mcr |= UART_MCR_RTS;
! 			serial_out(info, UART_MCR, mcr);
  		}
  		break;
  	}
***************
*** 634,646 ****
  /*
   * This routine is called when the serial port gets closed.  First, we
   * wait for the last remaining data to be sent.  Then, we unlink its
!  * ISR from the interrupt chain if necessary, and we free that IRQ if
!  * nothing is left in the chain.
   */
  static void rs_close(struct tty_struct *tty, struct file * filp)
  {
  	struct async_struct * info;
- 	async_ISR		ISR;
  	int irq, line;
  
  	line = DEV_TO_SL(tty->line);
--- 477,488 ----
  /*
   * This routine is called when the serial port gets closed.  First, we
   * wait for the last remaining data to be sent.  Then, we unlink its
!  * async structure from the interrupt chain if necessary, and we free
!  * that IRQ if nothing is left in the chain.
   */
  static void rs_close(struct tty_struct *tty, struct file * filp)
  {
  	struct async_struct * info;
  	int irq, line;
  
  	line = DEV_TO_SL(tty->line);
***************
*** 652,678 ****
  	if (!info->port)
  		return;
  	shutdown(info);
! #ifdef i386
! 	rs_write_active &= ~(1 << line);
! 	rs_event &= ~(1 << line);
! #else
! 	clear_bit(line, &rs_write_active);
! 	clear_bit(line, &rs_event);
! #endif
  	info->event = 0;
  	info->tty = 0;
! 	ISR = info->ISR;
! 	irq = ISR->irq;
! 	if (irq == 2)
! 		irq = 9;
! 	if (--ISR->refcnt == 0) {
! 		if (ISR->next_ISR)
! 			ISR->next_ISR->prev_ISR = ISR->prev_ISR;
! 		if (ISR->prev_ISR)
! 			ISR->prev_ISR->next_ISR = ISR->next_ISR;
  		else
! 			IRQ_ISR[irq] = ISR->next_ISR;
! 		if (!IRQ_ISR[irq])
  			free_irq(irq);
  	}
  }
--- 494,516 ----
  	if (!info->port)
  		return;
  	shutdown(info);
! 	clear_bit(line, rs_write_active);
! 	clear_bit(line, rs_event);
  	info->event = 0;
  	info->tty = 0;
! 	if (info->flags & ASYNC_NO_IRQ)
! 		info->flags &= ~ASYNC_NO_IRQ;
! 	else {
! 		irq = info->irq;
! 		if (irq == 2)
! 			irq = 9;
! 		if (info->next_port)
! 			info->next_port->prev_port = info->prev_port;
! 		if (info->prev_port)
! 			info->prev_port->next_port = info->next_port;
  		else
! 			IRQ_ports[irq] = info->next_port;
! 		if (!IRQ_ports[irq])
  			free_irq(irq);
  	}
  }
***************
*** 679,685 ****
  
  static void startup(struct async_struct * info)
  {
- 	unsigned short port = info->port;
  	unsigned short ICP;
  
  	/*
--- 517,522 ----
***************
*** 686,717 ****
  	 * First, clear the FIFO buffers and disable them
  	 */
  	if (info->type == PORT_16550A)
! 		outb_p(UART_FCR_CLEAR_CMD, UART_FCR + port);
  
  	/*
  	 * Next, clear the interrupt registers.
  	 */
! 	(void)inb_p(UART_LSR + port);
! 	(void)inb_p(UART_RX + port);
! 	(void)inb_p(UART_IIR + port);
! 	(void)inb_p(UART_MSR + port);
  
  	/*
  	 * Now, initialize the UART 
  	 */
! 	outb_p(UART_LCR_WLEN8, UART_LCR + port);	/* reset DLAB */
  	if (info->flags & ASYNC_FOURPORT) 
! 		outb_p(UART_MCR_DTR | UART_MCR_RTS, 
! 		       UART_MCR + port);
  	else
! 		outb_p(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2, 
! 		       UART_MCR + port);
  	
  	/*
  	 * Enable FIFO's if necessary
  	 */
  	if (info->type == PORT_16550A) {
! 		outb_p(UART_FCR_SETUP_CMD, UART_FCR + port);
  		info->xmit_fifo_size = 16;
  	} else {
  		info->xmit_fifo_size = 1;
--- 523,553 ----
  	 * First, clear the FIFO buffers and disable them
  	 */
  	if (info->type == PORT_16550A)
! 		serial_outp(info, UART_FCR, UART_FCR_CLEAR_CMD);
  
  	/*
  	 * Next, clear the interrupt registers.
  	 */
! 	(void)serial_inp(info, UART_LSR);
! 	(void)serial_inp(info, UART_RX);
! 	(void)serial_inp(info, UART_IIR);
! 	(void)serial_inp(info, UART_MSR);
  
  	/*
  	 * Now, initialize the UART 
  	 */
! 	serial_outp(info, UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
  	if (info->flags & ASYNC_FOURPORT) 
! 		serial_outp(info, UART_MCR, UART_MCR_DTR | UART_MCR_RTS);
  	else
! 		serial_outp(info, UART_MCR,
! 			    UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);
  	
  	/*
  	 * Enable FIFO's if necessary
  	 */
  	if (info->type == PORT_16550A) {
! 		serial_outp(info, UART_FCR, UART_FCR_SETUP_CMD);
  		info->xmit_fifo_size = 16;
  	} else {
  		info->xmit_fifo_size = 1;
***************
*** 720,754 ****
  	/*
  	 * Finally, enable interrupts
  	 */
! 	outb_p(0x0f,UART_IER + port);	/* enable all intrs */
  	if (info->flags & ASYNC_FOURPORT) {
  		/* Enable interrupts on the AST Fourport board */
! 		ICP = (port & 0xFE0) | 0x01F;
  		outb_p(0x80, ICP);
! 		(void) inb(ICP);
  	}
  
  	/*
  	 * And clear the interrupt registers again for luck.
  	 */
! 	(void)inb_p(UART_LSR + port);
! 	(void)inb_p(UART_RX + port);
! 	(void)inb_p(UART_IIR + port);
! 	(void)inb_p(UART_MSR + port);
  }
  
  static void shutdown(struct async_struct * info)
  {
! 	unsigned short port = info->port;
! 	
! 	outb_p(0x00,		UART_IER + port);	/* disable all intrs */
  	if (info->tty && !(info->tty->termios->c_cflag & HUPCL))
! 		outb_p(UART_MCR_DTR, UART_MCR + port);
  	else
  		/* reset DTR,RTS,OUT_2 */		
! 		outb_p(0x00,		UART_MCR + port);
! 	outb_p(UART_FCR_CLEAR_CMD, UART_FCR + info->port); /* disable FIFO's */
! 	(void)inb(UART_RX + port);     /* read data port to reset things */
  }
  
  void change_speed(unsigned int line)
--- 556,588 ----
  	/*
  	 * Finally, enable interrupts
  	 */
! 	serial_outp(info, UART_IER, 0x0f);	/* enable all intrs */
  	if (info->flags & ASYNC_FOURPORT) {
  		/* Enable interrupts on the AST Fourport board */
! 		ICP = (info->port & 0xFE0) | 0x01F;
  		outb_p(0x80, ICP);
! 		(void) inb_p(ICP);
  	}
  
  	/*
  	 * And clear the interrupt registers again for luck.
  	 */
! 	(void)serial_inp(info, UART_LSR);
! 	(void)serial_inp(info, UART_RX);
! 	(void)serial_inp(info, UART_IIR);
! 	(void)serial_inp(info, UART_MSR);
  }
  
  static void shutdown(struct async_struct * info)
  {
! 	serial_outp(info, UART_IER, 0x00);	/* disable all intrs */
  	if (info->tty && !(info->tty->termios->c_cflag & HUPCL))
! 		serial_outp(info, UART_MCR, UART_MCR_DTR);
  	else
  		/* reset DTR,RTS,OUT_2 */		
! 		serial_outp(info, UART_MCR, 0x00);
! 	serial_outp(info, UART_FCR, UART_FCR_CLEAR_CMD); /* disable FIFO's */
! 	(void)serial_in(info, UART_RX);    /* read data port to reset things */
  }
  
  void change_speed(unsigned int line)
***************
*** 789,799 ****
  		quot = 0;
  		info->timeout = 0;
  	}
! 	mcr = inb(UART_MCR + port);
  	if (quot) 
! 		outb(mcr | UART_MCR_DTR, UART_MCR + port);
  	else {
! 		outb(mcr & ~UART_MCR_DTR, UART_MCR + port);
  		return;
  	}
  	/* byte size and parity */
--- 623,633 ----
  		quot = 0;
  		info->timeout = 0;
  	}
! 	mcr = serial_in(info, UART_MCR);
  	if (quot) 
! 		serial_out(info, UART_MCR, mcr | UART_MCR_DTR);
  	else {
! 		serial_out(info, UART_MCR, mcr & ~UART_MCR_DTR);
  		return;
  	}
  	/* byte size and parity */
***************
*** 804,813 ****
  	if (!(cflag & PARODD))
  		cval |= 16;
  	cli();
! 	outb_p(cval | UART_LCR_DLAB, UART_LCR + port);	/* set DLAB */
! 	outb_p(quot & 0xff, UART_DLL + port);	/* LS of divisor */
! 	outb_p(quot >> 8, UART_DLM + port);	/* MS of divisor */
! 	outb(cval, UART_LCR + port);		/* reset DLAB */
  	sti();
  }
  
--- 638,647 ----
  	if (!(cflag & PARODD))
  		cval |= 16;
  	cli();
! 	serial_outp(info, UART_LCR, cval | UART_LCR_DLAB);	/* set DLAB */
! 	serial_outp(info, UART_DLL, quot & 0xff);	/* LS of divisor */
! 	serial_outp(info, UART_DLM, quot >> 8);		/* MS of divisor */
! 	serial_outp(info, UART_LCR, cval);		/* reset DLAB */
  	sti();
  }
  
***************
*** 821,828 ****
  	tmp.type = info->type;
  	tmp.line = info->line;
  	tmp.port = info->port;
! 	tmp.irq = info->ISR->irq;
! /*	tmp.flags = info->flags; */
  	memcpy_tofs(retinfo,&tmp,sizeof(*retinfo));
  	return 0;
  }
--- 655,663 ----
  	tmp.type = info->type;
  	tmp.line = info->line;
  	tmp.port = info->port;
! 	tmp.irq = info->irq;
! 	tmp.flags = info->flags;
! 	tmp.baud_base = info->baud_base;
  	memcpy_tofs(retinfo,&tmp,sizeof(*retinfo));
  	return 0;
  }
***************
*** 831,864 ****
  			   struct serial_struct * new_info)
  {
  	struct serial_struct tmp;
- 	async_ISR		ISR;
  	unsigned int 		new_port;
  	unsigned int		irq,new_irq;
  	int 			retval;
  	struct 			sigaction sa;
  
- 	if (!suser())
- 		return -EPERM;
  	if (!new_info)
  		return -EFAULT;
  	memcpy_fromfs(&tmp,new_info,sizeof(tmp));
  
! 	info->flags = tmp.flags & ASYNC_FLAGS;
! 	
! 	if ( (tmp.flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)
  		info->custom_divisor = tmp.custom_divisor;
! 	
  	if ((tmp.type >= PORT_UNKNOWN) && (tmp.type <= PORT_MAX))
  		info->type = tmp.type;
  	
  	new_port = tmp.port;
  	new_irq = tmp.irq;
! 	if (new_irq > 15 || new_port > 0xffff)
  		return -EINVAL;
  	if (new_irq == 2)
  		new_irq = 9;
! 	ISR = info->ISR;
! 	irq = ISR->irq;
  	if (irq == 2)
  		irq = 9;
  	if (irq != new_irq) {
--- 666,704 ----
  			   struct serial_struct * new_info)
  {
  	struct serial_struct tmp;
  	unsigned int 		new_port;
  	unsigned int		irq,new_irq;
  	int 			retval;
  	struct 			sigaction sa;
+ 	struct async_struct	old_info;
  
  	if (!new_info)
  		return -EFAULT;
  	memcpy_fromfs(&tmp,new_info,sizeof(tmp));
  
! 	old_info = *info;
! 	if (!suser()) {
! 		info->flags = ((info->flags & ~ASYNC_SPD_MASK) |
! 			       (tmp.flags & ASYNC_SPD_MASK));
  		info->custom_divisor = tmp.custom_divisor;
! 		goto check_and_exit;
! 	}
! 	info->baud_base = tmp.baud_base;
! 	info->flags = tmp.flags & ASYNC_FLAGS;
! 	info->custom_divisor = tmp.custom_divisor;
! 
  	if ((tmp.type >= PORT_UNKNOWN) && (tmp.type <= PORT_MAX))
  		info->type = tmp.type;
  	
  	new_port = tmp.port;
  	new_irq = tmp.irq;
! 	if (new_irq > 15 || new_port > 0xffff) {
! 		*info = old_info;
  		return -EINVAL;
+ 	}
  	if (new_irq == 2)
  		new_irq = 9;
! 	irq = info->irq;
  	if (irq == 2)
  		irq = 9;
  	if (irq != new_irq) {
***************
*** 867,904 ****
  		 * necessary, first we try to grab the new IRQ for
  		 * serial interrupts.
  		 */
! 		if (!IRQ_ISR[new_irq]) {
  			sa.sa_handler = rs_interrupt;
  			sa.sa_flags = (SA_INTERRUPT);
  			sa.sa_mask = 0;
  			sa.sa_restorer = NULL;
  			retval = irqaction(new_irq,&sa);
! 			if (retval)
  				return retval;
  		}
  
  		/*
! 		 * If the new IRQ is OK, now we unlink the ISR from
  		 * the existing interrupt chain.
  		 */
! 		if (ISR->next_ISR)
! 			ISR->next_ISR->prev_ISR = ISR->prev_ISR;
! 		if (ISR->prev_ISR)
! 			ISR->prev_ISR->next_ISR = ISR->next_ISR;
! 		else
! 			IRQ_ISR[irq] = ISR->next_ISR;
! 		if (!IRQ_ISR[irq])
! 			free_irq(irq);
! 
  		/*
  		 * Now link in the interrupt to the new interrupt chain.
  		 */
! 		ISR->prev_ISR = 0;
! 		ISR->next_ISR = IRQ_ISR[new_irq];
! 		if (ISR->next_ISR)
! 			ISR->next_ISR->prev_ISR = ISR;
! 		IRQ_ISR[new_irq] = ISR;
! 		ISR->irq = new_irq;
  	}
  	cli();
  	if (new_port != info->port) {
--- 707,750 ----
  		 * necessary, first we try to grab the new IRQ for
  		 * serial interrupts.
  		 */
! 		if (new_irq && !IRQ_ports[new_irq]) {
  			sa.sa_handler = rs_interrupt;
  			sa.sa_flags = (SA_INTERRUPT);
  			sa.sa_mask = 0;
  			sa.sa_restorer = NULL;
  			retval = irqaction(new_irq,&sa);
! 			if (retval) {
! 				*info = old_info;
  				return retval;
+ 			}
  		}
  
  		/*
! 		 * If the new IRQ is OK, now we unlink the async structure from
  		 * the existing interrupt chain.
  		 */
! 		if (irq) {
! 			if (info->next_port)
! 				info->next_port->prev_port = info->prev_port;
! 			if (info->prev_port)
! 				info->prev_port->next_port = info->next_port;
! 			else
! 				IRQ_ports[irq] = info->next_port;
! 			if (!IRQ_ports[irq])
! 				free_irq(irq);
! 		}
  		/*
  		 * Now link in the interrupt to the new interrupt chain.
  		 */
! 		info->prev_port = 0;
! 		if (new_irq) {
! 			info->next_port = IRQ_ports[new_irq];
! 			if (info->next_port)
! 				info->next_port->prev_port = info;
! 			IRQ_ports[new_irq] = info;
! 		} else
! 			info->next_port = 0;
! 		info->irq = new_irq;
  	}
  	cli();
  	if (new_port != info->port) {
***************
*** 906,925 ****
  		info->port = new_port;
  		startup(info);
  		change_speed(info->line);
  	}
  	sti();
  	return 0;
  }
  
  static int get_modem_info(struct async_struct * info, unsigned int *value)
  {
- 	unsigned port;
  	unsigned char control, status;
  	unsigned int result;
  
! 	port = info->port;
! 	control = inb(UART_MCR + port);
! 	status = inb(UART_MSR + port);
  	result =  ((control & UART_MCR_RTS) ? TIOCM_RTS : 0)
  		| ((control & UART_MCR_DTR) ? TIOCM_DTR : 0)
  		| ((status  & UART_MSR_DCD) ? TIOCM_CAR : 0)
--- 752,775 ----
  		info->port = new_port;
  		startup(info);
  		change_speed(info->line);
+ 		old_info = *info;		/* To avoid second change_speed */
  	}
  	sti();
+ 	
+ check_and_exit:
+ 	if (((old_info.flags & ASYNC_SPD_MASK) != (info->flags & ASYNC_SPD_MASK)) ||
+ 	    (old_info.custom_divisor != info->custom_divisor))
+ 		change_speed(info->line);
  	return 0;
  }
  
  static int get_modem_info(struct async_struct * info, unsigned int *value)
  {
  	unsigned char control, status;
  	unsigned int result;
  
! 	control = serial_in(info, UART_MCR);
! 	status = serial_in(info, UART_MSR);
  	result =  ((control & UART_MCR_RTS) ? TIOCM_RTS : 0)
  		| ((control & UART_MCR_DTR) ? TIOCM_DTR : 0)
  		| ((status  & UART_MSR_DCD) ? TIOCM_CAR : 0)
***************
*** 933,944 ****
  static int set_modem_info(struct async_struct * info, unsigned int cmd,
  			  unsigned int *value)
  {
- 	unsigned port;
  	unsigned char control;
  	unsigned int arg = get_fs_long((unsigned long *) value);
  	
! 	port = info->port;
! 	control = inb(UART_MCR + port);
  
  	switch (cmd) {
  		case TIOCMBIS:
--- 783,792 ----
  static int set_modem_info(struct async_struct * info, unsigned int cmd,
  			  unsigned int *value)
  {
  	unsigned char control;
  	unsigned int arg = get_fs_long((unsigned long *) value);
  	
! 	control = serial_in(info, UART_MCR);
  
  	switch (cmd) {
  		case TIOCMBIS:
***************
*** 961,967 ****
  		default:
  			return -EINVAL;
  	}
! 	outb(control, UART_MCR + port);
  	return 0;
  }
  
--- 809,815 ----
  		default:
  			return -EINVAL;
  	}
! 	serial_out(info, UART_MCR, control);
  	return 0;
  }
  
***************
*** 1001,1018 ****
  		return -EINVAL;
  	}
  	return 0;
! }	
  
  /*
   * This routine is called whenever a serial port is opened.  It
!  * enables interrupts for a serial port, linking in its interrupt into
!  * the ISR chain.   It also performs the serial-speicific
   * initalization for the tty structure.
   */
  int rs_open(struct tty_struct *tty, struct file * filp)
  {
  	struct async_struct	*info;
- 	async_ISR		ISR;
  	int 			irq, retval, line;
  	struct sigaction	sa;
  
--- 849,879 ----
  		return -EINVAL;
  	}
  	return 0;
! }
! 
! static void rs_set_termios(struct tty_struct *tty, struct termios *old_termios)
! {
! 	if (tty->termios->c_cflag == old_termios->c_cflag)
! 		return;
  
+ 	change_speed(DEV_TO_SL(tty->line));
+ 	
+ 	if ((old_termios->c_cflag & CRTSCTS) &&
+ 	    !(tty->termios->c_cflag & CRTSCTS)) {
+ 		tty->stopped = 0;
+ 		rs_write(tty);
+ 	}
+ }
+ 
  /*
   * This routine is called whenever a serial port is opened.  It
!  * enables interrupts for a serial port, linking in its async structure into
!  * the IRQ chain.   It also performs the serial-speicific
   * initalization for the tty structure.
   */
  int rs_open(struct tty_struct *tty, struct file * filp)
  {
  	struct async_struct	*info;
  	int 			irq, retval, line;
  	struct sigaction	sa;
  
***************
*** 1024,1041 ****
  	if ((line < 0) || (line >= NR_PORTS))
  		return -ENODEV;
  	info = rs_table + line;
! 	if (!info->port || !info->ISR->irq)
  		return -ENODEV;
  	info->tty = tty;
  	tty->write = rs_write;
  	tty->close = rs_close;
  	tty->ioctl = rs_ioctl;
  	tty->throttle = rs_throttle;
! 	ISR = info->ISR;
! 	irq = ISR->irq;
  	if (irq == 2)
  		irq = 9;
! 	if (!IRQ_ISR[irq]) {
  		sa.sa_handler = rs_interrupt;
  		sa.sa_flags = (SA_INTERRUPT);
  		sa.sa_mask = 0;
--- 885,913 ----
  	if ((line < 0) || (line >= NR_PORTS))
  		return -ENODEV;
  	info = rs_table + line;
! 	if (!info->port || !info->irq || !info->type) {
! #ifdef TTY_IO_ERROR
! 		set_bit(TTY_IO_ERROR, &tty->flags);
! 		info->flags |= ASYNC_NO_IRQ;
! 		info->tty = tty;
! 		tty->close = rs_close;
! 		tty->ioctl = rs_ioctl;
! 		return 0;
! #else
  		return -ENODEV;
+ #endif
+ 	} else
+ 		info->flags &= ~ASYNC_NO_IRQ;
  	info->tty = tty;
  	tty->write = rs_write;
  	tty->close = rs_close;
  	tty->ioctl = rs_ioctl;
  	tty->throttle = rs_throttle;
! 	tty->set_termios = rs_set_termios;
! 	irq = info->irq;
  	if (irq == 2)
  		irq = 9;
! 	if (!IRQ_ports[irq]) {
  		sa.sa_handler = rs_interrupt;
  		sa.sa_flags = (SA_INTERRUPT);
  		sa.sa_mask = 0;
***************
*** 1044,1060 ****
  		if (retval)
  			return retval;
  	}
! 	if (!ISR->refcnt++) {
! 		/*
! 		 * If this is the first time we're using this ISR,
! 		 * link it in.
! 		 */
! 		ISR->prev_ISR = 0;
! 		ISR->next_ISR = IRQ_ISR[irq];
! 		if (ISR->next_ISR)
! 			ISR->next_ISR->prev_ISR = ISR;
! 		IRQ_ISR[irq] = ISR;
! 	}
  	startup(info);
  	change_speed(info->line);
  	return 0;
--- 916,929 ----
  		if (retval)
  			return retval;
  	}
! 	/*
! 	 * Link in port to IRQ chain
! 	 */
! 	info->prev_port = 0;
! 	info->next_port = IRQ_ports[irq];
! 	if (info->next_port)
! 		info->next_port->prev_port = info;
! 	IRQ_ports[irq] = info;
  	startup(info);
  	change_speed(info->line);
  	return 0;
***************
*** 1062,1068 ****
  
  static void show_serial_version()
  {
! 	printk("Serial driver version 3.1 with");
  #ifdef CONFIG_AST_FOURPORT
  	printk(" AST_FOURPORT");
  #define SERIAL_OPT
--- 931,937 ----
  
  static void show_serial_version()
  {
! 	printk("Serial driver version 3.8 with");
  #ifdef CONFIG_AST_FOURPORT
  	printk(" AST_FOURPORT");
  #define SERIAL_OPT
***************
*** 1075,1084 ****
  	printk (" AUTO_IRQ");
  #define SERIAL_OPT
  #endif
- #ifdef NEW_INTERRUPT_ROUTINE
- 	printk(" NEW_INTERRUPT_ROUTINE");
- #define SERIAL_OPT
- #endif
  #ifdef SERIAL_OPT
  	printk(" enabled\n");
  #else
--- 944,949 ----
***************
*** 1095,1125 ****
  	unsigned short ICP=0, port = info->port;
  	unsigned long timeout;
  
  	/*
  	 * Enable interrupts and see who answers
  	 */
  	rs_irq_triggered = 0;
! 	scratch = inb_p(UART_IER + port);
! 	status1 = inb_p(UART_MCR + port);
  	if (info->flags & ASYNC_FOURPORT)  {
! 		outb_p(UART_MCR_DTR | UART_MCR_RTS, UART_MCR + port);
! 		outb_p(0x0f,UART_IER + port);	/* enable all intrs */
  		ICP = (port & 0xFE0) | 0x01F;
  		save_ICP = inb_p(ICP);
  		outb_p(0x80, ICP);
  		(void) inb(ICP);
  	} else {
! 		outb_p(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2, 
! 		       UART_MCR + port);
! 		outb_p(0x0f,UART_IER + port);	/* enable all intrs */
  	}
  	/*
  	 * Next, clear the interrupt registers.
  	 */
! 	(void)inb_p(UART_LSR + port);
! 	(void)inb_p(UART_RX + port);
! 	(void)inb_p(UART_IIR + port);
! 	(void)inb_p(UART_MSR + port);
  	timeout = jiffies+2;
  	while (timeout >= jiffies) {
  		if (rs_irq_triggered)
--- 960,994 ----
  	unsigned short ICP=0, port = info->port;
  	unsigned long timeout;
  
+ 	if (!info->port)
+ 		return;
+ 
  	/*
  	 * Enable interrupts and see who answers
  	 */
  	rs_irq_triggered = 0;
! 	scratch = serial_inp(info, UART_IER);
! 	status1 = serial_inp(info, UART_MCR);
  	if (info->flags & ASYNC_FOURPORT)  {
! 		serial_outp(info, UART_MCR, UART_MCR_DTR | UART_MCR_RTS);
! 		serial_outp(info, UART_IER, 0x0f);	/* enable all intrs */
  		ICP = (port & 0xFE0) | 0x01F;
  		save_ICP = inb_p(ICP);
  		outb_p(0x80, ICP);
  		(void) inb(ICP);
  	} else {
! 		serial_outp(info, UART_MCR,
! 			    UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);
! 		serial_outp(info, UART_IER, 0x0f);	/* enable all intrs */
  	}
  	/*
  	 * Next, clear the interrupt registers.
  	 */
! 	(void)serial_inp(info, UART_LSR);
! 	(void)serial_inp(info, UART_RX);
! 	(void)serial_inp(info, UART_IIR);
! 	(void)serial_inp(info, UART_MSR);
! 	
  	timeout = jiffies+2;
  	while (timeout >= jiffies) {
  		if (rs_irq_triggered)
***************
*** 1129,1139 ****
  	 * Now check to see if we got any business, and clean up.
  	 */
  	if (rs_irq_triggered) {
! 		outb_p(0, UART_IER + port);
! 		info->ISR->irq = rs_irq_triggered;
  	} else {
! 		outb_p(scratch, UART_IER + port);
! 		outb_p(status1, UART_MCR + port);
  		if (info->flags & ASYNC_FOURPORT)
  			outb_p(save_ICP, ICP);
  		info->type = PORT_UNKNOWN;
--- 998,1008 ----
  	 * Now check to see if we got any business, and clean up.
  	 */
  	if (rs_irq_triggered) {
! 		serial_outp(info, UART_IER, 0);
! 		info->irq = rs_irq_triggered;
  	} else {
! 		serial_outp(info, UART_IER, scratch);
! 		serial_outp(info, UART_MCR, status1);
  		if (info->flags & ASYNC_FOURPORT)
  			outb_p(save_ICP, ICP);
  		info->type = PORT_UNKNOWN;
***************
*** 1143,1158 ****
  	unsigned char status1, status2, scratch, scratch2;
  	unsigned short port = info->port;
  
  	/* 
  	 * Check to see if a UART is really there.  
  	 */
! 	scratch = inb_p(UART_MCR + port);
! 	outb_p(UART_MCR_LOOP | scratch, UART_MCR + port);
! 	scratch2 = inb_p(UART_MSR + port);
! 	outb_p(UART_MCR_LOOP | 0x0A, UART_MCR + port);
! 	status1 = inb_p(UART_MSR + port) & 0xF0;
! 	outb_p(scratch, UART_MCR + port);
! 	outb_p(scratch2, UART_MSR + port);
  	if (status1 != 0x90) {
  		info->type = PORT_UNKNOWN;
  		return;
--- 1012,1030 ----
  	unsigned char status1, status2, scratch, scratch2;
  	unsigned short port = info->port;
  
+ 	if (!info->port)
+ 		return;
+ 			
  	/* 
  	 * Check to see if a UART is really there.  
  	 */
! 	scratch = serial_inp(info, UART_MCR);
! 	serial_outp(info, UART_MCR, UART_MCR_LOOP | scratch);
! 	scratch2 = serial_inp(info, UART_MSR);
! 	serial_outp(info, UART_MCR, UART_MCR_LOOP | 0x0A);
! 	status1 = serial_inp(info, UART_MSR) & 0xF0;
! 	serial_outp(info, UART_MCR, scratch);
! 	serial_outp(info, UART_MSR, scratch2);
  	if (status1 != 0x90) {
  		info->type = PORT_UNKNOWN;
  		return;
***************
*** 1159,1165 ****
  	}
  #endif /* CONFIG_AUTO_IRQ */
  	
! 	if (!(info->flags & ASYNC_NOSCRATCH)) {
  		scratch = inb(UART_SCR + port);
  		outb_p(0xa5, UART_SCR + port);
  		status1 = inb(UART_SCR + port);
--- 1031,1055 ----
  	}
  #endif /* CONFIG_AUTO_IRQ */
  	
! 	outb_p(UART_FCR_ENABLE_FIFO, UART_FCR + port);
! 	scratch = inb(UART_IIR + port) >> 6;
! 	info->xmit_fifo_size = 1;
! 	switch (scratch) {
! 		case 0:
! 			info->type = PORT_16450;
! 			break;
! 		case 1:
! 			info->type = PORT_UNKNOWN;
! 			break;
! 		case 2:
! 			info->type = PORT_16550;
! 			break;
! 		case 3:
! 			info->type = PORT_16550A;
! 			info->xmit_fifo_size = 16;
! 			break;
! 	}
! 	if (info->type == PORT_16450) {
  		scratch = inb(UART_SCR + port);
  		outb_p(0xa5, UART_SCR + port);
  		status1 = inb(UART_SCR + port);
***************
*** 1166,1196 ****
  		outb_p(0x5a, UART_SCR + port);
  		status2 = inb(UART_SCR + port);
  		outb_p(scratch, UART_SCR + port);
!         } else {
! 	  	status1 = 0xa5;
! 		status2 = 0x5a;
! 	}
! 	if (status1 == 0xa5 && status2 == 0x5a) {
! 		outb_p(UART_FCR_ENABLE_FIFO, UART_FCR + port);
! 		scratch = inb(UART_IIR + port) >> 6;
! 		info->xmit_fifo_size = 1;
! 		switch (scratch) {
! 			case 0:
! 				info->type = PORT_16450;
! 				break;
! 			case 1:
! 				info->type = PORT_UNKNOWN;
! 				break;
! 			case 2:
! 				info->type = PORT_16550;
! 				break;
! 			case 3:
! 				info->type = PORT_16550A;
! 				info->xmit_fifo_size = 16;
! 				break;
! 		}
! 	} else
! 		info->type = PORT_8250;
  	shutdown(info);
  }
  
--- 1056,1064 ----
  		outb_p(0x5a, UART_SCR + port);
  		status2 = inb(UART_SCR + port);
  		outb_p(scratch, UART_SCR + port);
! 		if ((status1 != 0xa5) || (status2 != 0x5a))
! 			info->type = PORT_8250;
! 	}
  	shutdown(info);
  }
  
***************
*** 1218,1224 ****
  	timer_table[RS_TIMER].expires = 0;
  	
  	for (i = 0; i < 16; i++) {
! 		IRQ_ISR[i] = 0;
  #ifdef CONFIG_AUTO_IRQ
  		if (!irqaction(i, &sa))
  			irq_lines |= 1 << i;
--- 1086,1092 ----
  	timer_table[RS_TIMER].expires = 0;
  	
  	for (i = 0; i < 16; i++) {
! 		IRQ_ports[i] = 0;
  #ifdef CONFIG_AUTO_IRQ
  		if (!irqaction(i, &sa))
  			irq_lines |= 1 << i;
***************
*** 1239,1246 ****
  #endif
  	show_serial_version();
  	for (i = 0, info = rs_table; i < NR_PORTS; i++,info++) {
- 		if (!info->port)
- 			continue;
  		info->line = i;
  		info->tty = 0;
  		info->type = PORT_UNKNOWN;
--- 1107,1112 ----
***************
*** 1248,1265 ****
  		info->custom_divisor = 0;
  		info->x_char = 0;
  		info->event = 0;
! 		if (!info->ISR->line) {
! 			info->ISR->line = i;
! 			info->ISR->refcnt = 0;
! 			info->ISR->next_ISR = 0;
! 			info->ISR->prev_ISR = 0;
! 		}
  		init(info);
  		if (info->type == PORT_UNKNOWN)
  			continue;
  		printk("ttys%d%s at 0x%04x (irq = %d)", info->line, 
  		       (info->flags & ASYNC_FOURPORT) ? " FourPort" : "",
! 		       info->port, info->ISR->irq);
  		switch (info->type) {
  			case PORT_8250:
  				printk(" is a 8250\n");
--- 1114,1127 ----
  		info->custom_divisor = 0;
  		info->x_char = 0;
  		info->event = 0;
! 		info->next_port = 0;
! 		info->prev_port = 0;
  		init(info);
  		if (info->type == PORT_UNKNOWN)
  			continue;
  		printk("ttys%d%s at 0x%04x (irq = %d)", info->line, 
  		       (info->flags & ASYNC_FOURPORT) ? " FourPort" : "",
! 		       info->port, info->irq);
  		switch (info->type) {
  			case PORT_8250:
  				printk(" is a 8250\n");
***************
*** 1289,1294 ****
--- 1151,1159 ----
  			free_irq(i);
  	}
  #endif
+ 	bh_base[SERIAL_BH].routine = do_softint;
+ 	memset(&rs_event, 0, sizeof(rs_event));
+ 	memset(&rs_write_active, 0, sizeof(rs_write_active));
  	return kmem_start;
  }
  
