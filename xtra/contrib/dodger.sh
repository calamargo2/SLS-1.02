# This is my first attempt at an X11 game
# It was written exclusively in Xlib in X11 R4
#
# After the initial release of the game a number of bugs showed
# up, which have subsequently been fixed.
#
# For those who are trying to run this game on a stand alone
# workstation or on the console it may or may not work for you.
#
# I really designed it for a terminal out on the network somewhere.
# 
# Your performance (or lack of performance) has a lot to do with
# the hardware you are using.  So it may work for some, while others
# are having a heck of a time.  I cannot and will not design a game
# that will run correctly on every machine in the universe.
#
# to extract the files in this shar file just extract the file and
# type "sh file_name" and the files will appear  
#
# Enjoy!
#
# Bert Nelson
# Weber State University
# bnelson@csulx.weber.edu  
# 
#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 02/15/1992 19:02 UTC by bnelson@icarus
# Source directory /home/bnelson/X/Fixes/Dodger2/Dodger
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    125 -rw------- Dodger/Imakefile
#   9451 -rw------- Dodger/Makefile
#   1055 -rw------- Dodger/README
#  22876 -rw-r----- Dodger/dodger.c
#
# ============= Dodger/Imakefile ==============
if test ! -d 'Dodger'; then
    echo 'x - creating directory Dodger'
    mkdir 'Dodger'
fi
if test -f 'Dodger/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Dodger/Imakefile (File already exists)'
else
echo 'x - extracting Dodger/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Dodger/Imakefile' &&
IMAKE_DEFINES= -DManSuffix=6
X
DEFINES = -DX11R4
DEPLIBS = $(DEPXLIB)
LOCAL_LIBRARIES = $(XLIB)
X
SimpleProgramTarget(dodger)
X
SHAR_EOF
chmod 0600 Dodger/Imakefile ||
echo 'restore of Dodger/Imakefile failed'
Wc_c="`wc -c < 'Dodger/Imakefile'`"
test 125 -eq "$Wc_c" ||
	echo 'Dodger/Imakefile: original size 125, current size' "$Wc_c"
fi
# ============= Dodger/Makefile ==============
if test -f 'Dodger/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Dodger/Makefile (File already exists)'
else
echo 'x - extracting Dodger/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Dodger/Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
###########################################################################
# Makefile generated from "Imake.tmpl" and <Imakefile>
# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
#
# Platform-specific parameters may be set in the appropriate .cf
# configuration files.  Site-wide parameters may be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor doesn't define any unique symbols, you'll need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make Makefile", "make Makefiles", or "make World").
#
# If you absolutely can't get imake to work, you'll need to set the
# variables at the top of each Makefile as well as the dependencies at the
# bottom (makedepend will do this automatically).
#
X
###########################################################################
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.38 89/12/23 16:10:10 jim Exp $
# operating system:  SunOS 4.0.3
X
###########################################################################
# site-specific configuration parameters - edit site.def to change
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(TOP)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGSRC)
X        IMAKE_CMD = $(NEWTOP)$(IMAKE) -I$(NEWTOP)$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
###########################################################################
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
###########################################################################
# X Window System make variables; this need to be coordinated with rules
# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X        SOXLIBREV = 4.2
X          SOXTREV = 4.0
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = $(IMAKESRC)/imake
X           DEPEND = $(DEPENDSRC)/makedepend
X              RGB = $(RGBSRC)/rgb
X            FONTC = $(BDFTOSNFSRC)/bdftosnf
X        MKFONTDIR = $(MKFONTDIRSRC)/mkfontdir
X        MKDIRHIER = /bin/sh $(SCRIPTSRC)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -L$(EXTENSIONSRC) -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -L$(XLIBSRC) -lX11
X
X      DEPXAUTHLIB = $(XAUTHSRC)/libXau.a
X         XAUTHLIB =  $(DEPXAUTHLIB)
X
X        DEPXMULIB =
X           XMULIB = -L$(XMUSRC) -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -L$(OLDXLIBSRC) -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -L$(TOOLKITSRC) -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -L$(AWIDGETSRC) -lXaw
X
X LINTEXTENSIONLIB = $(EXTENSIONSRC)/lib/llib-lXext.ln
X         LINTXLIB = $(XLIBSRC)/llib-lX11.ln
X          LINTXMU = $(XMUSRC)/llib-lXmu.ln
X        LINTXTOOL = $(TOOLKITSRC)/llib-lXt.ln
X          LINTXAW = $(AWIDGETSRC)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
###########################################################################
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
###########################################################################
# start of Imakefile
X
IMAKE_DEFINES= -DManSuffix=6
X
DEFINES = -DX11R4
DEPLIBS = $(DEPXLIB)
LOCAL_LIBRARIES = $(XLIB)
X
X OBJS = dodger.o
X SRCS = dodger.c
X
X PROGRAM = dodger
X
all:: dodger
X
dodger: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
saber_dodger:
X	#load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
osaber_dodger:
X	#load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
install:: dodger
X	$(INSTALL) -c $(INSTPGMFLAGS)   dodger $(BINDIR)
X
install.man:: dodger.man
X	$(INSTALL) -c $(INSTMANFLAGS) dodger.man $(MANDIR)/dodger.n
X
depend:: $(DEPEND)
X
$(DEPEND):
X	@echo "checking $@ over in $(DEPENDSRC) first..."; \
X	cd $(DEPENDSRC); $(MAKE); \
X	echo "okay, continuing in $(CURRENT_DIR)"
X
depend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
###########################################################################
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) \#*
X
Makefile:: $(IMAKE)
X
$(IMAKE):
X	@(cd $(IMAKESRC); if [ -f Makefile ]; then \
X	echo "checking $@ in $(IMAKESRC) first..."; $(MAKE) all; else \
X	echo "bootstrapping $@ from Makefile.ini in $(IMAKESRC) first..."; \
X	$(MAKE) -f Makefile.ini BOOTSTRAPCFLAGS=$(BOOTSTRAPCFLAGS); fi; \
X	echo "okay, continuing in $(CURRENT_DIR)")
X
Makefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	#load $(ALLDEFINES) $(SRCS)
X
osaber:
X	#load $(ALLDEFINES) $(OBJS)
X
###########################################################################
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
###########################################################################
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0600 Dodger/Makefile ||
echo 'restore of Dodger/Makefile failed'
Wc_c="`wc -c < 'Dodger/Makefile'`"
test 9451 -eq "$Wc_c" ||
	echo 'Dodger/Makefile: original size 9451, current size' "$Wc_c"
fi
# ============= Dodger/README ==============
if test -f 'Dodger/README' -a X"$1" != X"-c"; then
	echo 'x - skipping Dodger/README (File already exists)'
else
echo 'x - extracting Dodger/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Dodger/README' &&
X
DO NOT RUN Dodger on a console.  This game was developed
and intended to be run out on plain, vanilla X terminals
with no graphics/anything accelerator boards.
X
X
Instructions for the program can be found in the first part
of the program dodger.c. 
X
After the initial release a number of fixes were made 
X
1) dodger now supports black and white displays
2) a problem with a variable named index was fixed
3) a time delay has been added for those with FAST machines
4) a lower level of play has been added
5) the game has been made more random 
X
Note on 3
X
If the program still runs TOO FAST on your machine try
upping the #defined constant named DELAY to slow things
down a bit.  For those on HP systems you may want to
increase it quite a bit.
X
On the other hand, if it runs TOO SLOW on your system just
set DELAY to zero to speed things up.
X
If the Makefile does not work just do the following 
X
cc dodger.c -lX11 -o dodger
X
Please make suggestions or comments about the game and send it to
X
bnelson@csulx.weber.edu
X
Bert Nelson
Weber State University 
SHAR_EOF
chmod 0600 Dodger/README ||
echo 'restore of Dodger/README failed'
Wc_c="`wc -c < 'Dodger/README'`"
test 1055 -eq "$Wc_c" ||
	echo 'Dodger/README: original size 1055, current size' "$Wc_c"
fi
# ============= Dodger/dodger.c ==============
if test -f 'Dodger/dodger.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Dodger/dodger.c (File already exists)'
else
echo 'x - extracting Dodger/dodger.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Dodger/dodger.c' &&
/* Bert Nelson
X   Weber State University
X   January 1992
X   Copyright 1992 Bert Nelson
X 
X   Permission to use, copy, modify, and distribute this software and its
X   documentation for any purpose and without fee is hereby granted,
X   provided that the above copyright notice appear in all copies and that
X   both that copyright notice and this permission notice appear in
X   supporting documentation.  It is provided "as is" without any express or 
X   implied warranty.
X 
X   Bert Nelson DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X   ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X   Bert Nelson BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X   ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X   WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X   ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X   SOFTWARE.
X 
X   History of fixes
X
X   1/9/92   changed index variable to index2 -- causes problems on Ultrix
X
X   1/10/92  made modifications so black and white displays will now work
X
X   1/10/92  time delay added 
X  
X   1/10/92  lower level of 4 was added 
X  
X   1/14/92  made ICCCM compliant 
X
X   1/20/92  made the game more random by using the time function
X
X   Dodger - a interactive graphics demo (a GAME!)    
X
X   Object of the game:  move the blue square across the screen
X			to the green ledge before the time
X                        runs out 
X
X                        You must reach the ledges on the
X                        screen in order to score
X 
X   Moving:  the 'j' and 'k' keys provide left and right movement
X
X   Levels of Play:  to adjust the level of play you can adjust the
X                    defined BASE value or just change the level
X                    at the command line by typing 
X			dodger -level x
X
X                    where x can be 1, 2, 3, or 4
X		    	1 = advanced
X                    	2 = intermediate   
X			3 = novice
X			4 = beginner
X
X	            two things change when you change the level of play
X                    1) the apparent speed of the blocks
X                    2) time left will change
X
X   Scoring:  you score for each level you go up and are given
X              a bonus based upon time left
X
X   Extra Lives:  you get a bonus player for each time you
X                 make it to the top level 
X
X   Colors:  if you want to change the colors do it
X            the color names are set up in a global variable
X
X   Feedback:  if you wish to provide me with feedback please
X              send comments or suggestions to my E-mail 
X              address at bnelson@csulx.weber.edu
X
X
X
*/
X
X
#include <stdio.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <sys/time.h>
X
#define DELAY 5
X		/* increase if things are a bit too fast */
X
X 
#define BASE 10    /*  
X			adjust this value up to make the blocks
X                        move faster or down to make the blocks
X                        move slower
X		   */ 
X                        
X
X	/* 
X		set up global variables 
X	*/
X
int cnt=0;
int index2=0;
int position=0;
int play_inc = 0;
int time2;
int level = 10;
int loop;
int loop2;
int lives = 5;
int random_num[2000];
int drawx;
int drawx2;
int drawy;
char message[10];
int drawy2;
int hi_score = 0;
int score = 0;
int game_level = 4;
int time_interval=0;
int speed_factor = 0;
char score_str[10];
char hi_score_str[10];
int play_level=400;
int time_left = 100;
int odd = 0;
GC gc;
int pid;
Font font;
static char *ncolors[10] = {
X	" ", "blue","red","green4",
X	"magenta1","CadetBlue","DodgerBlue2",
X	"DeepPink1","MediumBlue","red"};
unsigned long fore,back;
Colormap color_map;
XXColor colors[10];
XXColor exact_colors[10];
Window child1,child2,child3,child4,child5;
X
main(argc,argv)
int argc;
char **argv;
{
X
X	/*           
X		dodger bitmap for the icon 
X	*/
X
X	int dodger_height = 64;
X	int dodger_width = 64;
X
X	static char dodger_bits[] = 
X	{
X	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0e, 0xf8, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0x0e, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0x0e, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0e, 0xf8, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0x0e, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0x0e, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0e, 0xf8, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0x03, 0xfe, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0x03, 0xfe, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0x7f, 0xc0, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0x7f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0x7f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0x7f, 0xc0, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0x7f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0x7f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0x7f, 0xc0, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x0f,
X	0xf8, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x0f,
X	0xf8, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x0f,
X	0xf8, 0xff, 0x1f, 0x70, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x70,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x70, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0x1f, 0x70, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x70,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x70, 0xfe, 0xff, 0xff, 0xff,
X	0xff, 0xff, 0x1f, 0x70, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xc3, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0xfe, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xc3, 0xff, 0xff,
X	0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	};
X	
X	/*
X		set up local variables 
X	*/
X
X	Display *mydisplay;
X	Window  mywindow,player;
X
X	GC mygc;
X	XEvent myevent;
X	KeySym mykey;
X	XSizeHints myhint;
X        XWMHints wmhints;
X	unsigned long valuemask;
X	XSetWindowAttributes attributes;
X	Pixmap  iconpixmap;
X	int     h,w,x,y;
X	char icon[10];
X	char name[24];
X	int myscreen;
X	unsigned long myforeground, mybackground;
X	int i;
X	char text[10];
X	int quit;
X
X	if (argc < 2)
X		{
X		printf("\n	Usage:  dodger -level n \n");
X		printf("	        where n = 1, 2, 3, or 4\n");
X		printf("		1 = advanced\n");
X		printf("		2 = intermediate\n");
X		printf("		3 = novice\n");
X		printf("                4 = beginner\n\n");
X		printf("        Keyboard Commands\n\n");
X		printf("        s = start game\n"); 
X		printf("        q = quit current game\n");
X		printf("       qq = quit program\n");
X		printf("        j = move left\n");
X		printf("        k = move right\n\n");
X		exit(0);
X              	}
X
X	if (argc == 3) 
X		game_level = strtol(argv[2],NULL,10);
X
X	if (game_level > 4)
X		game_level = 4;
X
X	/* 
X		open up a display and get the default screen 
X	*/
X
X	mydisplay = XOpenDisplay("");
X
X	myscreen = DefaultScreen (mydisplay);
X
X
X	/* 
X		extract black and white colors from color map 
X	*/
X
X	back = mybackground = WhitePixel (mydisplay, myscreen);
X	fore = myforeground = BlackPixel (mydisplay, myscreen);
X
X	/* 
X		set up attributes for the window 
X	*/
X
X	myhint.x = 0;
X	myhint.y = 0;
X	myhint.width = 509;
X	myhint.height = 500;
X	myhint.min_width = 509;
X	myhint.max_width = 509;
X	myhint.min_height = 500;
X	myhint.max_height = 500;
X	myhint.flags = PMinSize|PMaxSize;
X
X	/* 
X		create a basic generic window with the above attributes 
X	*/
X
X	mywindow = XCreateSimpleWindow (mydisplay,
X	    DefaultRootWindow (mydisplay),
X	    myhint.x, myhint.y, myhint.width, myhint.height,
X	    0, myforeground, fore);
X	
X
X	color_set_up(mydisplay);
X
X	/*
X		set up the blue player
X	*/
X
X	player = XCreateSimpleWindow(mydisplay,
X	    mywindow,1,400,15,15,0,colors[1].pixel,colors[1].pixel);
X
X	valuemask = 0;
X
X	/*      
X		set the override redirect flag to true
X                in order to decrease the number of
X                events generated
X	*/
X
X	attributes.cursor = XCreateFontCursor(mydisplay,XC_left_ptr);
X	valuemask |=CWCursor;
X
X	child1 = XCreateWindow (mydisplay,
X	    mywindow,
X	    30, 0, 50, 35,0,0,
X	    InputOutput,CopyFromParent,valuemask,&attributes);
X
X	child2 = XCreateWindow (mydisplay,
X	    mywindow,
X	    130, 0, 50, 35,0,0, 
X	    InputOutput,CopyFromParent,valuemask,&attributes);
X
X	child3 = XCreateWindow (mydisplay,
X	    mywindow,
X	    230, 0, 50, 35,0,0,
X	    InputOutput,CopyFromParent,valuemask,&attributes);
X
X	child4 = XCreateWindow (mydisplay,
X	    mywindow,
X	    330, 0, 50, 35,0,0,
X	    InputOutput,CopyFromParent,valuemask,&attributes);
X
X	child5 = XCreateWindow (mydisplay,
X	    mywindow,
X	    430, 0, 50, 35,0,0,
X	    InputOutput,CopyFromParent,valuemask,&attributes);
X
X
X	/* Set up the title of the window and set up   
X	   background and foreground colors 
X	*/
X
X	XSetNormalHints(mydisplay,mywindow,&myhint);
X
X        wmhints.input = True;
X        wmhints.flags = InputHint;
X        XSetWMHints(mydisplay, mywindow, &wmhints);
X
X	/* 
X		set up the icon and the name of the window
X	*/
X
X	name[0] = '\0';
X
X	strcpy(name,"Dodger - by Bert Nelson");
X	strcpy(icon,"Dodger");
X
X	iconpixmap = XCreateBitmapFromData(mydisplay,
X	    mywindow,dodger_bits,dodger_width,dodger_height);
X
X	XSetStandardProperties(mydisplay,mywindow,name,icon,
X	    iconpixmap,argv,argc,&myhint);
X
X
X	mygc = XCreateGC (mydisplay, mywindow, 0, 0);
X
X	/* 
X		Load a font called 9x15 
X	*/
X
X
X	font = XLoadFont(mydisplay,"9x15");
X	XSetFont(mydisplay,mygc,font);
X
X
X	/* 
X		set foreground/background of children 
X	*/
X
X	XSetWindowBackground(mydisplay,child1,colors[2].pixel);
X	XSetWindowBackground(mydisplay,child2,colors[2].pixel);
X	XSetWindowBackground(mydisplay,child3,colors[2].pixel);
X	XSetWindowBackground(mydisplay,child4,colors[2].pixel);
X	XSetWindowBackground(mydisplay,child5,colors[2].pixel);
X	XSetBackground (mydisplay, mygc, mybackground);
X
X	/* 
X		ask for input from the keyboard 
X	*/
X
X
X	XSelectInput (mydisplay, mywindow,KeyPressMask|ButtonPressMask);
X
X	/* 
X		map the windows the the screen 
X	*/
X
X
X	XMapRaised (mydisplay,player);
X	XMapRaised (mydisplay, mywindow);
X	XMapRaised (mydisplay,child1);
X	XMapRaised (mydisplay,child2);
X	XMapRaised (mydisplay,child3);
X	XMapRaised (mydisplay,child4);
X	XMapRaised (mydisplay,child5);
X
X	quit = 0;
X
X	 
X                                        
X	while (quit == 0)
X	{
X		XNextEvent (mydisplay, &myevent );
X		switch (myevent.type)
X
X		{
X
X
X		case MappingNotify:
X			XRefreshKeyboardMapping (&myevent);
X			break;
X
X		case KeyPress:
X
X			i = XLookupString (&myevent, text, 10, &mykey, 0);
X
X			if (i == 1)
X			{
X				switch(text[0])
X				{
X				case 's' :
X					dodger(mydisplay,mywindow,player,mygc);
X					break;
X
X				case 'q' :
X
X					quit = 1;
X					break;
X
X
X				} 
X			} 
X		}
X	} 
X
X
X	/* 
X		Free up all the resources and shutdown gracefully 
X	*/
X
X	XFreeGC (mydisplay, mygc);
X	XDestroyWindow (mydisplay, mywindow);
X	XCloseDisplay (mydisplay);
X
X	exit(0);
X
} /* end main */
X
X
X
/*
X 	Purpose: get the pixel values for the named colors
*/
X
color_set_up(display)
X
Display *display;
X
{
X	int i;
X	int class;
X	Visual *viss;
X
X
X	/*
X		added to allow black and white terminals to work
X
X	*/
X
X	viss = DefaultVisual(display,0);
X
X	class = viss->class;
X
X	if (class == GrayScale || class == StaticGray)
X		{        
X			for (i=1; i<10; i++)
X				colors[i].pixel = WhitePixel(display,0);
X		}
X	
X	else
X
X	{
X	
X		color_map = DefaultColormap(display,0);
X
X	/* 
X		get the colors from the color map for the colors named 
X	*/
X
X		for (i=1; i<10; i++)
X			XAllocNamedColor(display,color_map,ncolors[i],
X		    		&exact_colors[i],&colors[i]);
X
X
X	}
}
X
X
X
/*
X	Purpose:  act as the main driver for the game
*/
X
X
dodger(display,parent,player,gc)
X
X
Display *display;
Window parent;
Window player;
GC gc;
{
X
X	XEvent event;
X	KeySym key;
X
X	int incj,inci,inck,incl;
X	int i,j,k,l;
X	  	
X	i=j=k=l=0;
X
X  	inci = level;
X        incj = level;
X        inck = level;
X        incl = level;
X
X	/*    
X		get the game set up
X	*/
X
X	initialize_game();
X	set_up(display,parent,gc,player,True);
X
X	/*
X		select input for parent and children windows 
X	*/
X
X	XSelectInput(display,parent,KeyPressMask|VisibilityChangeMask);
X	XSelectInput(display,child1,VisibilityChangeMask);
X	XSelectInput(display,child5,VisibilityChangeMask);
X	XSelectInput(display,player,VisibilityChangeMask);
X
X	/*
X		seed the random number generator and generate
X                2000 random numbers  why?  to speed up the
X                execution during the main loop
X	*/
X
X	srandom(time(NULL));
X
X	for (loop=0; loop<2000; loop++)
X		random_num[loop] = (random()/2279999 + 1)/100 + speed_factor;
X
X
X	for (;;)  /* forever */
X
X	{
X
X		/*
X			if you run out of time you lose a life
X		*/
X
X		if (time_left < 1)
X			lose_a_life(display,parent,gc,player);
X
X		/*
X		 	if no more lives return to main function
X                   	where you could quit or start another game
X		*/
X		if (lives < 1)
X			return(0);
X
X		/* reset position so you don't go off screen */
X
X		if (position < 7)
X			position = 7;
X
X		/* 
X			if you are on the left hand side of the screen
X                        or the right hand side of the screen without
X                        being hit you have scored 
X		*/
X
X
X		if (position > 485 && odd == 0
X
X		    || position < 15 && odd == 1   )
X		{
X			score_function(display,parent,gc,player);
X
X		}
X
X		/* 
X			increment the position of the blocks 
X		*/
X
X		j = j + incj;
X		i = i + inci;
X		k = k + inck;
X		l = l + incl;
X
X		/* 
X			move the blocks into their new windows 
X		*/
X
X
X		XMoveWindow(display,child1,30,i);
X		XMoveWindow(display,child2,130,j);
X		XMoveWindow(display,child3,230,k);
X		XMoveWindow(display,child4,330,l);
X		XMoveWindow(display,child5,430,i);
X
X		/*        
X			remove the XSync below if the program
X 			runs sluggish or slow 
X		*/
X
X		XSync(display,False);
X       	        time_delay(DELAY);
X 
X		time2++;
X
X		/* 
X			erase a slice of the time left bar 
X		*/
X
X		if (time2 == time_interval)
X		{
X			time2 = 0;
X			time_left = time_left - 1;
X			drawx = 20 + time_left;
X			XDrawLine(display,parent,gc, drawx,450,drawx,470);
X		}
X
X		/* 
X			reset random number index2 
X		*/
X
X		if (index2 > 1980)
X			index2 == 0;
X
X
X		/* if the blocks are near the top or bottom of the
X                   playing screen reverse the direction and change
X                   to a random speed.  this gives the appearance of
X                   bouncing blocks 
X		*/
X
X
X		if (j < 20)
X		{
X			j = 15;
X			incj =  random_num[index2++];
X		}
X
X		if (j >= 370)
X		{
X			incj = - 1 * random_num[index2++];
X		}
X
X		if (i < 20)
X		{
X			i = 15;
X			inci =  random_num[index2++];
X		}
X
X		if (i >= 370)
X			inci = -1 *   random_num[index2++];
X
X
X		if (k < 20)
X		{
X			k = 15;
X			inck =  random_num[index2++];
X		}
X
X		if (k >= 370)
X			inck = -1 *  random_num[index2++];
X
X		if (l < 20)
X		{
X			l = 15;
X			incl =  random_num[index2++];
X		}
X
X		if (l >= 370)
X			incl = -1 *  random_num[index2++];
X
X		/* 
X			check to see if there are any new events on 
X                   	the queue and branch accordingly 
X		
X		*/
X
X   		XSync(display,False);
X
X
X		if (XEventsQueued(display,QueuedAfterReading)>0 )
X		{
X
X			XNextEvent(display,&event);
X
X
X			switch(event.type)
X			{
X
X			case VisibilityNotify:
X
X				/* if the window is moved partially
X				   off the screen or if the window
X				   is iconified redraw the information
X				   part of the screen 
X				*/
X
X				if (event.xvisibility.window != player)
X					set_up(display,parent,gc,player,True);
X
X					/* otherwise you lose 1 life */
X				else
X				{
X					lose_a_life(display,parent,gc,player);
X					if (lives < 1)
X						return(0);
X				}
X				break;
X
X			case KeyPress:
X
X				message[0] = '\0';
X				cnt = XLookupString(&event,message,10,&key,0);
X
X				/* 
X				   set player to move every 5 pixels 
X				*/
X
X				play_inc = 5;
X
X				/* 
X				   trap to make sure you don't 
X				   go off the screen	
X				*/
X
X				if (position > 485 )
X				{
X					cnt = 0;
X					position = 485;
X				}
X
X				/* 
X					quit current game and return to main 
X				*/
X
X				if (cnt == 1 && message[0] == 'q')
X					lives = 0;
X				/*
X					move left
X				*/
X
X				if (cnt == 1 && message[0] == 'j')
X					position -= play_inc;
X
X				/* 
X					move right 
X				*/
X
X				if (cnt == 1 && message[0] == 'k')
X					position += play_inc;
X				/* 
X					move player to the new position 
X					however if j or k is not pressed
X                                   	the player is not moved 	
X				*/
X
X				XMoveWindow(display,player,position,play_level);
X				break;
X			}
X		}
X		
X
X	}
X
}
X
/*
X	Purpose:  initialize values
*/
X
initialize_game()
{
X
X	int i;
X	play_level = 400;
X	position = 7;
X	odd = 0;
X	lives = 5;
X	time_left = 100;
X	time_interval = game_level*3;
X	speed_factor = BASE + (3-game_level * 3);
X	/*
X		if the score from the last game
X		is greater than the high score then
X		make it the new high score
X	*/
X
X	if (score > hi_score)
X	{
X		hi_score = score;
X		sprintf(hi_score_str,"%d ",hi_score);
X	}
X
X	/*     
X		fill score string with blanks
X	*/
X
X	score = 0;
X	for (i=0; i<9; i++)
X		score_str[i] = ' ';
X	score_str[9] = '\0';
X
X	time2=0;
}
X
/*
X	Purpose:  set up the scoring and lives
*/
X
X
set_up(display,parent,gc,player,flag)
Display *display;
Window parent;
GC gc;
Window player;
Bool flag;
X
X
{
X	XGCValues values;
X	unsigned long mask=0;
X
X	XMoveWindow(display,player,position,play_level);
X
X	/*
X		if the flag is set do this
X	*/
X
X	if (flag)
X	{
X
X		values.line_width = 9;
X		mask = GCLineWidth;
X
X		XChangeGC(display,gc,mask,&values);
X		XSetForeground(display,gc,colors[5].pixel);
X
X		XDrawLine(display,parent,gc,0,430,509,430);
X		values.line_width = 3;
X		XChangeGC(display,gc,mask,&values);
X		/* 
X			Draw Time Left, Score and Lives 
X		*/
X
X		XSetForeground(display,gc,WhitePixel(display,0));
X		XSetBackground(display,gc,BlackPixel(display,0));
X
X
X		XDrawImageString(display,parent,gc,20,495,"TIME LEFT",9);
X
X		XDrawImageString(display,parent,gc,190,495,"HI",2);
X
X		XDrawImageString(display,parent,gc,270,495,"SCORE",5);
X
X		XDrawImageString(display,parent,gc,410,495,"LIVES",5);
X
X		XDrawImageString(display,parent,gc,280,470,
X		    score_str,strlen(score_str));
X
X		XDrawImageString(display,parent,gc,180,470,
X		    hi_score_str,strlen(hi_score_str));
X
X		XSetForeground(display,gc,colors[3].pixel);
X
X
X		drawy = 417;
X
X		for (loop=0; loop<8; loop++)
X		{
X
X			XDrawLine(display,parent,gc,0,drawy,28,drawy);
X			XDrawLine(display,parent,gc,481,drawy,509,drawy);
X			drawy = drawy - 50;
X
X		}
X
X
X	}
X	/* 
X		change the color and create the timing bar 
X	*/
X
X	XSetForeground(display,gc,colors[4].pixel);
X
X	XFillRectangle(display,parent,gc,
X		    20,450,time_left,20);
X
X	XSetForeground(display,gc,WhitePixel(display,0));
X
X	XDrawImageString(display,parent,gc,280,470,
X		    score_str,strlen(score_str));
X
X	/* 
X		redraw the number of lives left
X	*/
X
X	XClearArea(display,parent,380,450,120,15,False);
X
X	XSetForeground(display,gc,colors[1].pixel);
X
X	for (loop2=lives; loop2>0; --loop2)
X	{
X		drawx=380+20*loop2;
X		XFillRectangle(display,parent,gc,drawx,450,15,15);
X	}
X
X
X	XSetForeground(display,gc,BlackPixel(display,0));
X
X	/*
X		dump the queue NOW
X	*/
X
X	XSync(display,True);
X
}
/*
X	Purpose:  erase one life and end game (if 0 lives left)
*/
X
lose_a_life(display,parent,gc,player)
Display *display;
Window parent;
GC	gc;
Window player;
X
X
X
{
X	/* 
X		reset everything
X	*/
X
X	odd = 0;
X	position = 7;
X	time_left = 100;
X	lives = lives - 1;
X
X	XMoveWindow(display,player,position,play_level);
X	set_up(display,parent,gc,player,False);
X
X	/* 
X		if no more lives are left
X 		bail out
X	*/
X
X	if (lives < 1)
X	{
X		XMoveWindow(display,player,position,play_level);
X		XSync(display,True);
X		return(0);  /* exit module */
X	}
X
}
/*
X	Purpose:  compute and display score
X                  if the player reaches the top
X                  then add one life and change
X                  the colors of the blocks
*/
X
score_function(display,parent,gc,player)
Display *display;
Window parent;
GC      gc;
Window player;
X
X
X
{
X	static int idx=5;
X	play_level = play_level-50;
X
X	/* 
X		toggle the odd value so you can score  
X	*/
X
X	if (odd == 0)
X	{
X		position = 485;
X		odd = 1;
X	}
X	else
X		odd = 0;
X
X	/*       
X		change colors and restart at begining if
X                you make it to the top
X	*/
X
X
X	if (play_level < 50 )
X	{
X		/*
X			add a life
X		*/
X
X		lives = lives + 1;
X	  	set_up(display,parent,gc,player,False);
X
X		play_level = 400;
X		idx++;
X		if (idx > 10)
X			idx = 6;
X		XSetWindowBackground(display,child1,colors[idx].pixel);
X		XSetWindowBackground(display,child2,colors[idx].pixel);
X		XSetWindowBackground(display,child3,colors[idx].pixel);
X		XSetWindowBackground(display,child4,colors[idx].pixel);
X		XSetWindowBackground(display,child5,colors[idx].pixel);
X
X		XUnmapSubwindows(display,parent);
X
X		XMapRaised  (display,player);
X		XMapRaised (display,child1);
X		XMapRaised (display,child2);
X		XMapRaised (display,child3);
X		XMapRaised (display,child4);
X		XMapRaised (display,child5);
X
X	}
X
X	/*              
X		give a base score of 200 plus a bonus for time left
X	*/
X 
X	score = score + 200 + time_left*5;
X
X	time_left = 100;
X
X	/* 
X		display the new score
X	*/
X	
X	XSetForeground(display,gc,WhitePixel(display,0));
X	XSetBackground(display,gc,BlackPixel(display,0));
X
X	sprintf(score_str,"%d ",score);
X	score_str[strlen(score_str)+1] = '\0';
X	XDrawImageString(display,parent,gc,280,470,
X	    score_str,strlen(score_str));
X
X	/* 
X		move up to a new level
X	*/
X
X	XMoveWindow(display,player,position,play_level);
X
X	/* 
X		change the color and create the timing bar 
X	*/
X
X	XSetForeground(display,gc,colors[4].pixel);
X
X	XFillRectangle(display,parent,gc,
X	    20,450,time_left,20);
X
X	/*
X		dump the events queue 
X	*/
X
X	XSetForeground(display,gc,BlackPixel(display,0));
X	XSync(display,True);
X
}
X
time_delay(usec)
int usec;
{
X 
X        static struct timeval tv;
X 
X        tv.tv_sec = (long) 0;
X        tv.tv_usec = (long) usec;
X 
X        select(0,0,0,0,&tv);
X 
}
X
X      
X
X
X
X
X
X
X
X
SHAR_EOF
chmod 0640 Dodger/dodger.c ||
echo 'restore of Dodger/dodger.c failed'
Wc_c="`wc -c < 'Dodger/dodger.c'`"
test 22876 -eq "$Wc_c" ||
	echo 'Dodger/dodger.c: original size 22876, current size' "$Wc_c"
fi
exit 0
